[{"node": {"avatar_large": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_large.png?m=1700771269", "name": "programmer", "avatar_normal": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_normal.png?m=1700771269", "title": "程序员", "url": "https://www.v2ex.com/go/programmer", "topics": 62980, "footer": "", "header": "While code monkeys are not eating bananas, they're coding.", "title_alternative": "Programmer", "avatar_mini": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_mini.png?m=1700771269", "stars": 8977, "aliases": [], "root": false, "id": 300, "parent_node_name": "computer"}, "member": {"id": 657012, "username": "drymonfidelia", "url": "https://www.v2ex.com/u/drymonfidelia", "website": "", "twitter": null, "psn": null, "github": null, "btc": null, "location": "", "tagline": "", "bio": "", "avatar_mini": "https://cdn.v2ex.com/gravatar/017bcef6e642dbf067e17838a9cd447a?s=24&d=retro", "avatar_normal": "https://cdn.v2ex.com/gravatar/017bcef6e642dbf067e17838a9cd447a?s=48&d=retro", "avatar_large": "https://cdn.v2ex.com/gravatar/017bcef6e642dbf067e17838a9cd447a?s=73&d=retro", "created": 1698662217, "last_modified": 1716639831}, "last_reply_by": "conan257", "last_touched": 1717318867, "title": "要对单个 6.20TB 的超大 csv 文件保持顺序的情况下进行去除重复行，有什么好思路？显然不可能加载进内存", "url": "https://www.v2ex.com/t/1046023", "created": 1717251260, "deleted": 0, "content": "", "content_rendered": "", "last_modified": 1717251260, "replies": 62, "id": 1046023}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/4ea0/6fbc/770_large.png?m=1695370146", "name": "career", "avatar_normal": "https://cdn.v2ex.com/navatar/4ea0/6fbc/770_normal.png?m=1695370146", "title": "职场话题", "url": "https://www.v2ex.com/go/career", "topics": 17204, "footer": "", "header": "这里，我们聊聊那些工作中遇到的开心和不开心的事。", "title_alternative": "Career", "avatar_mini": "https://cdn.v2ex.com/navatar/4ea0/6fbc/770_mini.png?m=1695370146", "stars": 3140, "aliases": [], "root": false, "id": 770, "parent_node_name": "work"}, "member": {"id": 680304, "username": "Kathy1989", "url": "https://www.v2ex.com/u/Kathy1989", "website": null, "twitter": null, "psn": null, "github": null, "btc": null, "location": null, "tagline": null, "bio": null, "avatar_mini": "https://cdn.v2ex.com/avatar/14d1/1cb5/680304_mini.png?m=1715343271", "avatar_normal": "https://cdn.v2ex.com/avatar/14d1/1cb5/680304_normal.png?m=1715343271", "avatar_large": "https://cdn.v2ex.com/avatar/14d1/1cb5/680304_large.png?m=1715343271", "avatar_xlarge": "https://cdn.v2ex.com/avatar/14d1/1cb5/680304_xlarge.png?m=1715343271", "avatar_xxlarge": "https://cdn.v2ex.com/avatar/14d1/1cb5/680304_xlarge.png?m=1715343271", "created": 1710400387, "last_modified": 1715343271}, "last_reply_by": "LifStge", "last_touched": 1717322715, "title": "你们有共情老板的情结吗？", "url": "https://www.v2ex.com/t/1046046", "created": 1717263037, "deleted": 0, "content": "作为员工，你会有共情老板的情结吗？\r\n例如“老板真不容易，花那么多钱开公司招人，他压力很大，我应该多体谅他。他心情不好 PUA 我时，我也应该理解他，并且在不加工资的情况下主动多加班。老板跟我一样上有老下有小，他 7x24 小时工作，而且他没工资，我 5x8 小时感到很惭愧”\r\n\r\n或者作为老板，你希望员工这样共情你吗？\r\n\r\n听老范节目说，以前在 F 盛的公司里，很多 40 岁的程序员被老板批得哭着从会议室走出来", "content_rendered": "作为员工，你会有共情老板的情结吗？<br />例如“老板真不容易，花那么多钱开公司招人，他压力很大，我应该多体谅他。他心情不好 PUA 我时，我也应该理解他，并且在不加工资的情况下主动多加班。老板跟我一样上有老下有小，他 7x24 小时工作，而且他没工资，我 5x8 小时感到很惭愧”<br /><br />或者作为老板，你希望员工这样共情你吗？<br /><br />听老范节目说，以前在 F 盛的公司里，很多 40 岁的程序员被老板批得哭着从会议室走出来", "last_modified": 1717291831, "replies": 53, "id": 1046046}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c74d/97b0/16_large.png?m=1707293361", "name": "share", "avatar_normal": "https://cdn.v2ex.com/navatar/c74d/97b0/16_normal.png?m=1707293361", "title": "分享发现", "url": "https://www.v2ex.com/go/share", "topics": 41313, "footer": "", "header": "分享你看到的好玩的，有信息量的，欢迎从这里获取灵感。", "title_alternative": "Share", "avatar_mini": "https://cdn.v2ex.com/navatar/c74d/97b0/16_mini.png?m=1707293361", "stars": 5811, "aliases": [], "root": false, "id": 16, "parent_node_name": "v2ex"}, "member": {"id": 659198, "username": "198plus", "url": "https://www.v2ex.com/u/198plus", "website": "", "twitter": null, "psn": null, "github": null, "btc": null, "location": "", "tagline": "", "bio": "", "avatar_mini": "https://cdn.v2ex.com/gravatar/2c5e7a344a9bb0dc9428763dbe6b6cc5?s=24&d=retro", "avatar_normal": "https://cdn.v2ex.com/gravatar/2c5e7a344a9bb0dc9428763dbe6b6cc5?s=48&d=retro", "avatar_large": "https://cdn.v2ex.com/gravatar/2c5e7a344a9bb0dc9428763dbe6b6cc5?s=73&d=retro", "created": 1698932176, "last_modified": 1698932176}, "last_reply_by": "aulayli", "last_touched": 1717325928, "title": "现在的老师是为了赚钱。。。。！", "url": "https://www.v2ex.com/t/1046103", "created": 1717305237, "deleted": 0, "content": "还没中考就让交钱 400 预订职校学位！\r\n\r\n推荐一个学生去上县的最烂职校有几千的回扣，为得到职校了几千块的回扣。。。。无语！\r\n\r\n\r\n\r\n\r\n\r\n初三班群班主任的发言如下：\r\n\r\n@所有人 \r\n        各位家长早上好。对于孩子是否报读职校，我还是诠释一下:报名职校与高中招生是没有任何冲突的，都是高中招生后，才到职校招生的，两者不同一批次。报名职校是作为报高中的后备方案，万一考不上高中，也可以通过读职校参加语数英三科高考而圆大学之梦。\r\n        而有些家长因孩子考不上高中就准备不让孩子读书了，这想法更不可取。试问一下，你如果是一位女生的母亲，你会让女儿嫁一个只是初中毕业的男人吗？我想大多数母亲都会反对的，相同的道理，男生如成为成功男土，你父母也会反对孩子娶一个只有初中学历的媳妇的。所以让孩子多读几年书，以后人生会更精彩！\r\n        当然报名只是后备方案，考上高中或考不上，不去读这 400 元书费都会全额退回的。而专业就是先报先得。建议还没报名的家长慎重考虑一下，多替你孩子想想以后，不要让他在初中毕业后就掉队了，失去竞争的可能。", "content_rendered": "<p>还没中考就让交钱 400 预订职校学位！</p>\n<p>推荐一个学生去上县的最烂职校有几千的回扣，为得到职校了几千块的回扣。。。。无语！</p>\n<p>初三班群班主任的发言如下：</p>\n<p>@所有人\n各位家长早上好。对于孩子是否报读职校，我还是诠释一下:报名职校与高中招生是没有任何冲突的，都是高中招生后，才到职校招生的，两者不同一批次。报名职校是作为报高中的后备方案，万一考不上高中，也可以通过读职校参加语数英三科高考而圆大学之梦。\n而有些家长因孩子考不上高中就准备不让孩子读书了，这想法更不可取。试问一下，你如果是一位女生的母亲，你会让女儿嫁一个只是初中毕业的男人吗？我想大多数母亲都会反对的，相同的道理，男生如成为成功男土，你父母也会反对孩子娶一个只有初中学历的媳妇的。所以让孩子多读几年书，以后人生会更精彩！\n当然报名只是后备方案，考上高中或考不上，不去读这 400 元书费都会全额退回的。而专业就是先报先得。建议还没报名的家长慎重考虑一下，多替你孩子想想以后，不要让他在初中毕业后就掉队了，失去竞争的可能。</p>\n", "last_modified": 1717305237, "replies": 46, "id": 1046103}, {"node": {"avatar_large": "/static/img/node_default_large.png", "name": "taobao", "avatar_normal": "/static/img/node_default_normal.png", "title": "淘宝", "url": "https://www.v2ex.com/go/taobao", "topics": 364, "footer": null, "header": null, "title_alternative": "淘宝", "avatar_mini": "/static/img/node_default_mini.png", "stars": 69, "aliases": [], "root": false, "id": 726, "parent_node_name": null}, "member": {"id": 589794, "username": "nightnotlate", "url": "https://www.v2ex.com/u/nightnotlate", "website": null, "twitter": null, "psn": null, "github": null, "btc": null, "location": null, "tagline": null, "bio": null, "avatar_mini": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_mini.png?m=1660731939", "avatar_normal": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_normal.png?m=1660731939", "avatar_large": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_large.png?m=1660731939", "avatar_xlarge": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_xlarge.png?m=1660731939", "avatar_xxlarge": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_xlarge.png?m=1660731939", "avatar_xxxlarge": "https://cdn.v2ex.com/avatar/0bb6/d4a5/589794_xlarge.png?m=1660731939", "created": 1659317123, "last_modified": 1660731939}, "last_reply_by": "htxy1985", "last_touched": 1717325160, "title": "后知后觉发现某宝很多评价是假的", "url": "https://www.v2ex.com/t/1046085", "created": 1717297103, "deleted": 0, "content": "一个款式的包 ，不同品牌，不同店铺。\n发现评价居然是一样的，来自同样的人，同样的文字，同样的照片。\n刷一个店铺我能理解。\n但是给不同店铺刷评价，是什么道理呢？\n一 平台所为？（应该不至于吧）\n二 刚好两家店铺请到了同一个机器人？\n还是别的原因呢\n求教", "content_rendered": "一个款式的包 ，不同品牌，不同店铺。<br />发现评价居然是一样的，来自同样的人，同样的文字，同样的照片。<br />刷一个店铺我能理解。<br />但是给不同店铺刷评价，是什么道理呢？<br />一 平台所为？（应该不至于吧）<br />二 刚好两家店铺请到了同一个机器人？<br />还是别的原因呢<br />求教", "last_modified": 1717301594, "replies": 35, "id": 1046085}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/03af/dbd6/63_large.png?m=1644490200", "name": "java", "avatar_normal": "https://cdn.v2ex.com/navatar/03af/dbd6/63_normal.png?m=1644490200", "title": "Java", "url": "https://www.v2ex.com/go/java", "topics": 5921, "footer": "", "header": "Sun 公司发明，被广泛使用的一门编程语言。", "title_alternative": "Java", "avatar_mini": "https://cdn.v2ex.com/navatar/03af/dbd6/63_mini.png?m=1644490200", "stars": 5599, "aliases": [], "root": false, "id": 63, "parent_node_name": "programming"}, "member": {"id": 479145, "username": "HikariLan", "url": "https://www.v2ex.com/u/HikariLan", "website": "https://www.minecraft.kim", "twitter": "", "psn": "", "github": "shaokeyibb", "btc": "", "location": "西安", "tagline": "兰草凋荡，星辰璀璨", "bio": "", "avatar_mini": "https://cdn.v2ex.com/avatar/c527/329c/479145_mini.png?m=1698024421", "avatar_normal": "https://cdn.v2ex.com/avatar/c527/329c/479145_normal.png?m=1698024421", "avatar_large": "https://cdn.v2ex.com/avatar/c527/329c/479145_large.png?m=1698024421", "avatar_xlarge": "https://cdn.v2ex.com/avatar/c527/329c/479145_xlarge.png?m=1698024421", "avatar_xxlarge": "https://cdn.v2ex.com/avatar/c527/329c/479145_xlarge.png?m=1698024421", "avatar_xxxlarge": "https://cdn.v2ex.com/avatar/c527/329c/479145_xlarge.png?m=1698024421", "created": 1585228227, "last_modified": 1698024421}, "last_reply_by": "MeatIndustry", "last_touched": 1717322165, "title": "过去、现在和未来 —— Java 的现代化之路", "url": "https://www.v2ex.com/t/1046015", "created": 1717247767, "deleted": 0, "content": "# 过去、现在和未来 —— Java 的现代化之路\r\n\r\nJava ，一门广受赞誉，却又饱受诟病的语言，在从其诞生至今，便无时不刻的被于其他语言对比，有时候这种对比是空穴来风的诽谤，但更多的是对这门语言未来的担心，而近 10 年来涌现的一个又一个新生的程序语言更是让 Java 一次又一次地被推上风口浪尖，使公众一次又一次的质疑：Java ，是否真的停滞不前了？\r\n\r\n2024 年，从大街上随便抓一个 Java 程序员，询问其 Java 有哪些槽点，我相信你的这个下午大概是别想离开这个人的声音了 —— 从泛型不支持基本数据类型到各种各样令人抓耳挠腮的奇怪问题，你绝对可以听这个人滔滔不绝地说上一整天。那么这些问题 Java 官方知道吗？当然知道，他们在解决吗？ Ummm ，至少我们可以说，他们一直以来都正在积极的为解决这些问题而努力，并且有些槽点，其实早已在最新版本的 Java 中被解决。\r\n\r\n因此，本篇文章的目的，便是带领读者从过去走向现在，再走向未来，回顾并前瞻 Java 已经推出，或是即将推出的全新特性，这些特性再 Java 的历史中都扮演着决定性的作用，为 Java“赶 Go 超 Rust”贡献着自己的努力。\r\n\r\n碍于篇幅所限，我们将只重点提及几个 Java 语言史上的重大改动，而其他小的（但不代表不重要）更新，我们姑且一概掠过。若要了解 Java 从过去到现在全部的特性更新，也许你可以看看 OpenJDK 的 Java 特性提案索引页 [JEP 0: JEP Index]( https://openjdk.org/jeps/0)，了解更多。\r\n\r\n## Java8：Lambda 表达式和 Stream API\r\n\r\nJava 8 无论是从 JVM 层面的变动，还是 Java 语法和标准库的变动，都可以说是 Java 有史以来第一次大规模的增补，毋庸置疑的，这次更新也为 Java 带来了第二春，使之焕发新生，而其长达近 20 年的 LTS 支持，也使其成为了 Java 历史上使用率最高，最经久不衰的 Java 版本。\r\n\r\n在这次更新中，Java 自然是引入了全新且复杂的 Date & Time API ，看起来好像有点用但实际上很鸡肋的 Optional API 这类谈不上小但是也很难说重大的标准库修补。但是更为被人津津乐道，且在本人看来是 Java 8 最重要的两个更新，便是 Lambda 表达式和 Stream API 。\r\n\r\n### Lambda 表达式\r\n\r\n也许是考虑到兼容性，也许就是纯粹 Java 开发者懒，自 Java 7 以前，Java 虚拟机（ JVM ）基本没有什么重大改动，纵然 Java 语言已经引入了诸如自动拆装箱、参数化类型（泛型）这样的重大语言特性，JVM 依然不动如山，全靠 `javac` 衬托。\r\n\r\n然而到了 Java 7 ，天塌了。JVM 引入了一个全新的指令 `invokedynamic`，其可以在运行时动态的分派一个函数调用，这个指令最初并没有被 Java 语言本身所使用，相反，它的出现是为了解决基于 JVM 的动态类型语言（例如 Groovy ）在运行时由于 JVM 无法支持函数类型动态分派而导致的巨大性能问题。\r\n\r\n而这个指令第一次在 Java 语言中登场，便是神奇的 Lambda 表达式了。\r\n\r\n即使你不知道 Lambda 表达式，或者他背后的函数式接口，我相信你一定写过这样的代码：\r\n\r\n```java\r\nnew Thread(() -> Foo.bar()).start(); // 更好的一个写法其实是 new Thread(Foo::bar).start();\r\n```\r\n\r\n这很自然，就像你可能不会泛型编程，但一定也用过带泛型的 Java 容器一样。但如果我告诉你，在过去的 Java 版本中，人们只能这么写：\r\n\r\n```java\r\nnew Thread(new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        Foo.bar();\r\n    }\r\n}).start();\r\n```\r\n\r\n是不是会有一种天然的碰见庞然大物的恐惧感。而事实上，在 Java 8 以前，函数式编程是不可能的，这主要源自于 Java 的一个语法缺陷：在 Java 中，函数（方法）不是一等公民。\r\n\r\n什么是“一等公民”？来看看在 JavaScript 中大家习以为常的一段代码：\r\n\r\n```javascript\r\nfunction foo(){\r\n  console.log(\"foo!\");\r\n}\r\n\r\nfunction bar(barFoo){\r\n  barFoo();\r\n}\r\n\r\nbar(foo);\r\n```\r\n\r\n最后一行中，我们为 `bar` 函数直接传入 `foo` 函数作为其实参，并在 `bar` 函数中调用这个函数。我们可以将一个函数（或者说，函数指针）作为参数传入到函数中，就像其他数据类型一样。\r\n\r\n但是 Java 是没有办法直接传入函数指针的，如果你了解 C# 的话，C# 用 `Delegate`（委托）机制解决这个问题，而 Java 则绕的更远一些，选择了 `Functional Interface`（函数式接口）作为其函数式编程的解决方案。那么，什么是函数式接口？\r\n\r\n通俗的来讲，任意一个仅有一个抽象方法的接口，都是函数式接口（无论其是否标注 `@FunctionalInterface` 注解），例如我们上边看到的 `Thread` 构造方法中的 `Runnable` 接口：\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Runnable {\r\n    /**\r\n     * When an object implementing interface <code>Runnable</code> is used\r\n     * to create a thread, starting the thread causes the object's\r\n     * <code>run</code> method to be called in that separately executing\r\n     * thread.\r\n     * <p>\r\n     * The general contract of the method <code>run</code> is that it may\r\n     * take any action whatsoever.\r\n     *\r\n     * @see     java.lang.Thread#run()\r\n     */\r\n    public abstract void run();\r\n}\r\n```\r\n\r\n这个接口只有一个名为 `run` 的抽象方法，并没有任何返回值。我们可以为需要函数式接口实例的地方传入 Lambda 表达式，在运行时，Lambda 表达式会被转换为对应函数式接口的实例，就像我们为 `Thread` 传入构造函数参数所做的那样一样。\r\n\r\n当然，请不要误解我的意思，并不是自 Java 8 引入函数式接口这个概念之后，才有了 `Runnable` 接口，相反，`Runnable` 接口古早有之，是函数式接口的概念被引入后，`Runnable` 也正巧成为了函数式接口的一部分。\r\n\r\n### Stream API\r\n\r\nLambda 表达式的一大创新之处，就是为在 Java 语言进行函数式编程提供了可能，由此，Stream （流） API 应运而生。这里所说的“流”并不是指 I/O 流，而是一种数据流动的管道。举个例子，现在有一个包含 10000 个数字的 `int` 数组：\r\n\r\n```java\r\nint[] array = new int[10000];\r\n```\r\n\r\n我想找出该数组中所有数字大于 5000 的数字，然后让他们加一个不大于 500 的随机数，最后求和。在不使用 Stream API 的情况下我们会这么写：\r\n\r\n```java\r\npublic int sumRandomNumber(int[] array, Random random){\r\n        int rst = 0;\r\n        for (int i : array) {\r\n            if (i > 5000) {\r\n                rst += i + random.nextInt(500);\r\n            }\r\n        }\r\n        return rst;\r\n    }\r\n```\r\n\r\n但如果有了 Stream API ，只需要一行代码就可以解决：\r\n\r\n```java\r\npublic int sumRandomNumberWithStreamAPI(int[] array, Random random) {\r\n        return Arrays.stream(array).filter(i -> i > 5000).map(i -> i + random.nextInt(500)).sum();\r\n    }\r\n```\r\n\r\n在上述代码中，我们通过调用 `Arrays.stream` 方法将 `array` 转换为一个 `IntStream` 流对象，然后顺次调用 `filter` 和 `map` 流中间方法，过滤和映射数据，最终调用 `sum` 流终结方法，获得求和结果。\r\n\r\n一种特定类型的数据经过流中间方法的加工处理，最终经过流终结方法收集为我们想要的形式，这极大地提高了开发效率，而在以前的 Java 中，想要达成这样的操作，会使代码变得极度复杂。\r\n\r\n## Project Loom：Java 迈向现代化的第一步\r\n\r\n相信各位对“Coroutine （协程）”这个名词一定不陌生，被称为“轻量级线程”的它，在 I/O 密集型的应用程序开发领域可谓是如日中天。所谓“协程”，便是一种用户态的线程，它们构建于线程之上，由用户程序负责调度，而不是操作系统。比起原生的操作系统线程，他更轻量，而比起 Event Loop （事件循环）的解决方案，它又能保证对用户程序足够透明，降低开发过程中的心智负担。\r\n\r\n许多现代语言都配备了协程的原生支持，尽管它们各自的实现方式并不相同，例如 Go 的 `Goroutine`，Kotlin 的 `Kotlin Coroutines` 或是 C++ 20 的 `Coroutines`。在早期版本的 Java 中，其实有一个名为“Green thread （绿色线程）”的协程实现，但因为各种原因，最终被替换回了现在的操作系统线程。\r\n\r\n但是我们确实需要协程，于是 2017 年，Project Loom 应运而生，它的使命就是为 Java 提供自己的有栈协程实现，早期被称为“Fiber （纤程）”，后被称为“Virtual thread （虚拟线程）”，经过两个大版本的预览，其终于在 Java 21 中正式推出，这意味着 Java 平台也拥有了自己的原生协程实现。\r\n\r\n于是现在，你可以通过 Thread 对象的静态工厂方法 `ofVirtual` 创建一个虚拟线程:\r\n\r\n```java\r\nThread.ofVirtual().start(()->{\r\n\t// some heavy IO stuff\r\n});\r\n```\r\n\r\n就是这么简单，如果你在用 Spring Boot 3 ，只需要一行配置便可以在你的项目中启用虚拟线程支持：\r\n\r\n```properties\r\nspring.threads.virtual.enabled=true\r\n```\r\n\r\n很简单对不？现在就去试试看吧，我保证带来的性能提升是立竿见影的。\r\n\r\n当然有关并发编程，另一个绕不开的话题便是异步编程了，Java 目前原生的异步编程由 `Future` 等对象支持，用起来不能说十分好用，只能说味同嚼蜡。在 Java 19 引入的 Structured Concurrency （结构化并发）事实上在一定程度上为异步编程提供了更好的解决方案，篇幅所限，在这里我们也不再展开。\r\n\r\n## Project Panama：外地人向本地人的妥协\r\n\r\n长期以来，Java 一直以“一次编写，到处运行”作为自己的卖点，然而很不幸的是，Java 没能向开发者提供所有他们想要的原材料，因此，开发者们决定自己做，最终，在各种 JNI 函数和 Unsafe 调用的狂轰滥炸下，Java 最终还是变成了“一次编写，到处调试”的样子。\r\n\r\nJNI 好用吗？我相信没人会说好用，不然也不可能会有 JNA 一类的库出现，JNI 看似提供了 Java 向 native 调用的接口，但实际上它完全不够灵活，无法在运行时根据程序的需要动态的链接不同的函数。自 Java 1.1 引入 JNI 开始，这个东西就基本没什么变化，大家只能捏着鼻子用这样一套并不好用的东西，或者只能叹叹气，然后另寻他法。\r\n\r\n再回过头来看看 Unsafe ，在过去版本的 Java 中，管理堆外内存是非常复杂且危险的，尤其是当我们通过 hacky 的方式获取 `sun.misc.Unsafe` 类实例，并使用其中的 `allocateMemory` 方法来分配堆外内存时。这意味着，我们需要手动管理这些堆外内存的分配和释放，一不小心，就可能造成 JVM 虚拟机和 GC 无法处理的内存泄漏。\r\n\r\n有些人可能会说：JVM 本来就不希望你使用堆外内存，你为什么要这么用，这不是自找没趣吗？但是很遗憾的是，有时要想获得高性能的数据吞吐或是确保数据的一致性，我们不得不这么做，例如在 Java 中使用 `mmap`, CAS ，或是设置内存屏障。在 Java 8 ，如果你想设置一个操作系统级别的重量级锁，你可以使用 `LockSupport.park`；自 Java 9 开始，如果你想对一个对象中的字段 CAS 写入，则可以用 `VarHandle.compareAndSet` 方法；但是其他 JVM 未能提供的操作，也许你只能像使用 JNI 一样，绕一个大圈，或是看看社区上有没有已经做好的，也许可能充满各种漏洞的小玩具。\r\n\r\n但是事情还是需要解决的，最终这场争端以 Java 这个外地人向本地人的妥协而告终：Project Panama 应运而生。经过三个大版本的预览，Project Panama 的一个重要特性，The Foreign Function & Memory (FFM) API 终于在 Java 22 正式落地。FFM API 有什么用？首先，它可以提供灵活的本地库访问：\r\n\r\n```java\r\nLinker linker = Linker.nativeLinker();\r\nSymbolLookup stdlib = linker.defaultLookup();\r\nMethodHandle strlen = linker.downcallHandle(\r\n    stdlib.find(\"strlen\").orElseThrow(),\r\n    FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)\r\n);\r\n\r\ntry (Arena arena = Arena.ofConfined()) {\r\n    MemorySegment cString = arena.allocateFrom(\"Hello\");\r\n    long len = (long)strlen.invokeExact(cString); // 5\r\n}\r\n```\r\n\r\n上述代码创建了一个操作系统标准库的链接器，在其中查找 `strlen` 函数并以一个从 JVM 创建的堆外字符串作为参数执行，获取结果。在这个过程中，还需要告诉 JVM 函数和参数的内存布局，以便 JVM 可以正确传入他们。\r\n\r\n接下来，FFM API 向我们提供了更适合 Java 宝宝的堆外内存 API ，Arena ，你可以通过这种方式创建一个会自动被 GC 清理的堆外内存：\r\n\r\n```java\r\nMemorySegment segment = Arena.ofAuto().allocate(100, 1);\r\n...\r\nsegment = null; // the segment region becomes available for deallocation after this point\r\n```\r\n\r\n或者，你可以直接创建一个基于作用域的堆外内存，并使用 `try-with-resource` 语法包裹，只要离开 `try` 作用域，则分配的堆外内存会被自动释放：\r\n\r\n```java\r\nMemorySegment segment = null;\r\ntry (Arena arena = Arena.ofConfined()) {\r\n    segment = arena.allocate(100);\r\n    ...\r\n} // segment region deallocated here\r\nsegment.get(ValueLayout.JAVA_BYTE, 0); // throws IllegalStateException\r\n```\r\n\r\n别忘了 `mmap`，现在 FFM API 可以直接提供这种支持，只需要调用 `FileChannel.map` 方法即可：\r\n\r\n``` java\r\nArena arena = Arena.ofAuto();\r\ntry {\r\n    try (FileChannel channel = FileChannel.open(Path.of(\"large_file\"), StandardOpenOption.READ)) {\r\n        MemorySegment segment = channel.map(FileChannel.MapMode.READ_ONLY, 0, FILE_SIZE, arena);\r\n        // use segment in your way\r\n    }\r\n} catch (IOException e) {\r\n    throw new RuntimeException(e);\r\n}\r\n```\r\n\r\n是不是简简又单单呢？有了 FFM API 这把瑞士军刀，相信以后 Java 能做的事情会更有趣和疯狂。\r\n\r\n## Project Valhalla：走向未来\r\n\r\n至此，我们已经介绍完了 Java 走向现代化三座大山中已经落地的前两座，如你所见的是，他们每一个都充满诱惑，十分大胆，令 Java 焕发新生，但是 Project Valhalla 将带给我们的，比前面我讲过的那些特性更加疯狂，更加颠覆：为 Java 引入值类型对象，补上长久以来 Java 泛型编程的缺陷，并为 JVM 虚拟机提供运行时可见的泛型参数。\r\n\r\n让我们先来回忆一下泛型的前世今生：泛型于 Java 1.5 被首次引入，其更官方、也更直观的名称应该是 Parameterized Type （参数化类型），其允许将类型作为类或函数的参数提供，以便于更好的进行类型检查或是根据不同的泛型特化代码实现，然而后者并不被 Java 泛型所支持，因为 Java 泛型采用的方案于 C++, Go, Rust 这些语言的泛型方案有本质不同：Java 的泛型只是编译器语法糖，在运行时并没有影响代码执行，这意味着，当你在 C++ 中使用 `Vector<bool>` 和 `Vector<int>` 时，C++ 编译器事实上会生产两个不同版本的 `Vector` 类（这也是其名称“模板”的由来），但 Java 并不会改变这一点，`List<Boolean>` 和 `List<Integer>` 和其未泛化原始类型 `List` 没有任何差别，编译器会在需要提供或返回泛型参数时帮你做类型安全检查或自动类型转换，而 JVM 不会感知到泛型的存在。\r\n\r\n泛化泛型和具化泛型的争端从未停止，本文也无心讨论此两者之间各自的优劣，但是不可否认是，泛化泛型确实为 Java 引入了一个难以逾越的语法鸿沟：那就是参数化类型无法接受基本数据类型作为参数，这意味着在 C# 程序员严重看起来十分正常的代码：\r\n\r\n```c#\r\nList<int> list = new List<>();\r\n```\r\n\r\n在 Java 中是不可能的。而长久以来，Java 程序员只能被迫在需要将基本数据类型放入集合的场景下进退两难：要么把 `int` 装箱成 `Integer`，忍受额外的对象创建开销；要么自行构建，或者使用各种工具库提供的特化集合类型（例如 `IntArrayList`, `DoubleArrayList` 等）。而事实上，这种语法鸿沟在 Java 中由来已久，例如 `switch` 语句不支持 `double` 等类型，`instanceof` 关键字不支持针对基本数据类型的模式匹配等，颇令新手疑惑，好在在最近的版本（ Java 23 ）中，[这些问题都逐步得到完善]( https://openjdk.org/jeps/455)，进入预览的流程。\r\n\r\n再回过头来看看基本数据类型的装箱机制，这实际上是十分不明智的，因为基本数据类型这种可能被程序大量使用的数据，他们本应将其数值直接存储到内存中，而不是被包装一个含有比他们实际内容更为复杂的对象和对象头，这无疑增加了系统的内存压力。而参数化类型对基本数据类型的缺位更是加剧了这一问题。\r\n\r\n为此，Project Valhalla 横空出世，直指这些痛点问题，并推出了它们的解决方案：值类型和通用泛型。\r\n\r\n在未来的 Java 版本中，我们将可以通过 `value class` 标识创建一个值类型类：\r\n\r\n```java\r\nvalue record Color(byte red, byte green, byte blue) {} // 值记录类型\r\n```\r\n\r\n这种类型没有对象头，其 `hashCode` 直接据其所含字段计算，这同时也意味着，对值类型进行 `==` 比较将会比较其值，而不是其地址。在未来，所有的基本数据类型包装类都会被升级为这种值类型。而原本的类型将会被称为 Identity class ，意为具有身份的类型。\r\n\r\n而通用泛型（这是一个早前叫法，但我觉得放到这里更直观，所以接着沿用下来）将允许我们在未来在泛型中直接使用基本数据类型作为泛型参数，而这种实现有可能依然是通过自动拆装箱实现的。\r\n\r\n如果你恰巧用过 Java 16 及以上的版本，你可能会发现有一个新特性和上述特性有点类似，那就是 Record （记录）类型，该特性允许你通过简单的语法创建一个不可变的 POJO 对象，并为其实现 `equals`/`hashCode`/`toString` 方法和构造函数，而不必由你手动实现，或是使用额外的 `@lombok.Data` 和 `@lombok.AllArgsConstructor`注解：\r\n\r\n```java\r\nrecord Point(int x, int y) { } // 通过 new Point(0, 0) 构造，通过 point.x()/point.y() 访问\r\n```\r\n\r\n但实际上，record 和 value class 是有本质区别的。Record 本质上还是一个对象，他依然是一个特殊的语法糖，并没有改变对象的本质；而 value class 则彻底颠覆了 Java 原有的对象模型。\r\n\r\n除此之外，Project Valhalla 还有一些很有意思的提案，例如为 JVM 添加可 null 和非 null 类型，就将 C# 和 Kotlin 所做的那样；亦或者在运行时保留泛型参数，提供特化类型的实现等。\r\n\r\n最后要说的是，Project Valhalla 的相关提案仍在不断更新，早在草案时期，相关提案就已被推翻重置了多次，因此对于该提案的相关描述在未来可能会是不准确的，希望读者悉知。\r\n\r\n## 引用\r\n\r\n- [JEP 444: Virtual Threads (openjdk.org)]( https://openjdk.org/jeps/444)\r\n\r\n- [JEP 454: Foreign Function & Memory API (openjdk.org)]( https://openjdk.org/jeps/454)\r\n\r\n- [JEP 471: Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal (openjdk.org)]( https://openjdk.org/jeps/471)\r\n\r\n- [java.lang.foreign (Java SE 22 & JDK 22) (oracle.com)]( https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/package-summary.html)\r\n\r\n- [Arena (Java SE 22 & JDK 22) (oracle.com)]( https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Arena.html)\r\n\r\n- [FileChannel (Java SE 22 & JDK 22) (oracle.com)]( https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode,long,long))\r\n\r\n- [Project Valhalla (openjdk.org)]( https://openjdk.org/projects/valhalla/)\r\n\r\n- [JEP 395: Records (openjdk.org)]( https://openjdk.org/jeps/395)\r\n\r\n- [JEP 401: Value Classes and Objects (Preview) (openjdk.org)]( https://openjdk.org/jeps/401)\r\n\r\n- [JEP 402: Enhanced Primitive Boxing (Preview) (openjdk.org)]( https://openjdk.org/jeps/402)\r\n\r\n- [JEP 455: Primitive Types in Patterns, instanceof, and switch (Preview) (openjdk.org)]( https://openjdk.org/jeps/455)", "content_rendered": "<h1>过去、现在和未来 —— Java 的现代化之路</h1>\n<p>Java ，一门广受赞誉，却又饱受诟病的语言，在从其诞生至今，便无时不刻的被于其他语言对比，有时候这种对比是空穴来风的诽谤，但更多的是对这门语言未来的担心，而近 10 年来涌现的一个又一个新生的程序语言更是让 Java 一次又一次地被推上风口浪尖，使公众一次又一次的质疑：Java ，是否真的停滞不前了？</p>\n<p>2024 年，从大街上随便抓一个 Java 程序员，询问其 Java 有哪些槽点，我相信你的这个下午大概是别想离开这个人的声音了 —— 从泛型不支持基本数据类型到各种各样令人抓耳挠腮的奇怪问题，你绝对可以听这个人滔滔不绝地说上一整天。那么这些问题 Java 官方知道吗？当然知道，他们在解决吗？ Ummm ，至少我们可以说，他们一直以来都正在积极的为解决这些问题而努力，并且有些槽点，其实早已在最新版本的 Java 中被解决。</p>\n<p>因此，本篇文章的目的，便是带领读者从过去走向现在，再走向未来，回顾并前瞻 Java 已经推出，或是即将推出的全新特性，这些特性再 Java 的历史中都扮演着决定性的作用，为 Java“赶 Go 超 Rust”贡献着自己的努力。</p>\n<p>碍于篇幅所限，我们将只重点提及几个 Java 语言史上的重大改动，而其他小的（但不代表不重要）更新，我们姑且一概掠过。若要了解 Java 从过去到现在全部的特性更新，也许你可以看看 OpenJDK 的 Java 特性提案索引页 <a href=\"https://openjdk.org/jeps/0\" rel=\"nofollow\">JEP 0: JEP Index</a>，了解更多。</p>\n<h2>Java8：Lambda 表达式和 Stream API</h2>\n<p>Java 8 无论是从 JVM 层面的变动，还是 Java 语法和标准库的变动，都可以说是 Java 有史以来第一次大规模的增补，毋庸置疑的，这次更新也为 Java 带来了第二春，使之焕发新生，而其长达近 20 年的 LTS 支持，也使其成为了 Java 历史上使用率最高，最经久不衰的 Java 版本。</p>\n<p>在这次更新中，Java 自然是引入了全新且复杂的 Date &amp; Time API ，看起来好像有点用但实际上很鸡肋的 Optional API 这类谈不上小但是也很难说重大的标准库修补。但是更为被人津津乐道，且在本人看来是 Java 8 最重要的两个更新，便是 Lambda 表达式和 Stream API 。</p>\n<h3>Lambda 表达式</h3>\n<p>也许是考虑到兼容性，也许就是纯粹 Java 开发者懒，自 Java 7 以前，Java 虚拟机（ JVM ）基本没有什么重大改动，纵然 Java 语言已经引入了诸如自动拆装箱、参数化类型（泛型）这样的重大语言特性，JVM 依然不动如山，全靠 <code>javac</code> 衬托。</p>\n<p>然而到了 Java 7 ，天塌了。JVM 引入了一个全新的指令 <code>invokedynamic</code>，其可以在运行时动态的分派一个函数调用，这个指令最初并没有被 Java 语言本身所使用，相反，它的出现是为了解决基于 JVM 的动态类型语言（例如 Groovy ）在运行时由于 JVM 无法支持函数类型动态分派而导致的巨大性能问题。</p>\n<p>而这个指令第一次在 Java 语言中登场，便是神奇的 Lambda 表达式了。</p>\n<p>即使你不知道 Lambda 表达式，或者他背后的函数式接口，我相信你一定写过这样的代码：</p>\n<pre><code class=\"language-java\">new Thread(() -&gt; Foo.bar()).start(); // 更好的一个写法其实是 new Thread(Foo::bar).start();\n</code></pre>\n<p>这很自然，就像你可能不会泛型编程，但一定也用过带泛型的 Java 容器一样。但如果我告诉你，在过去的 Java 版本中，人们只能这么写：</p>\n<pre><code class=\"language-java\">new Thread(new Runnable() {\n    @Override\n    public void run() {\n        Foo.bar();\n    }\n}).start();\n</code></pre>\n<p>是不是会有一种天然的碰见庞然大物的恐惧感。而事实上，在 Java 8 以前，函数式编程是不可能的，这主要源自于 Java 的一个语法缺陷：在 Java 中，函数（方法）不是一等公民。</p>\n<p>什么是“一等公民”？来看看在 JavaScript 中大家习以为常的一段代码：</p>\n<pre><code class=\"language-javascript\">function foo(){\n  console.log(\"foo!\");\n}\n\nfunction bar(barFoo){\n  barFoo();\n}\n\nbar(foo);\n</code></pre>\n<p>最后一行中，我们为 <code>bar</code> 函数直接传入 <code>foo</code> 函数作为其实参，并在 <code>bar</code> 函数中调用这个函数。我们可以将一个函数（或者说，函数指针）作为参数传入到函数中，就像其他数据类型一样。</p>\n<p>但是 Java 是没有办法直接传入函数指针的，如果你了解 C# 的话，C# 用 <code>Delegate</code>（委托）机制解决这个问题，而 Java 则绕的更远一些，选择了 <code>Functional Interface</code>（函数式接口）作为其函数式编程的解决方案。那么，什么是函数式接口？</p>\n<p>通俗的来讲，任意一个仅有一个抽象方法的接口，都是函数式接口（无论其是否标注 <code>@FunctionalInterface</code> 注解），例如我们上边看到的 <code>Thread</code> 构造方法中的 <code>Runnable</code> 接口：</p>\n<pre><code class=\"language-java\">@FunctionalInterface\npublic interface Runnable {\n    /**\n     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used\n     * to create a thread, starting the thread causes the object's\n     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing\n     * thread.\n     * &lt;p&gt;\n     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may\n     * take any action whatsoever.\n     *\n     * @see     java.lang.Thread#run()\n     */\n    public abstract void run();\n}\n</code></pre>\n<p>这个接口只有一个名为 <code>run</code> 的抽象方法，并没有任何返回值。我们可以为需要函数式接口实例的地方传入 Lambda 表达式，在运行时，Lambda 表达式会被转换为对应函数式接口的实例，就像我们为 <code>Thread</code> 传入构造函数参数所做的那样一样。</p>\n<p>当然，请不要误解我的意思，并不是自 Java 8 引入函数式接口这个概念之后，才有了 <code>Runnable</code> 接口，相反，<code>Runnable</code> 接口古早有之，是函数式接口的概念被引入后，<code>Runnable</code> 也正巧成为了函数式接口的一部分。</p>\n<h3>Stream API</h3>\n<p>Lambda 表达式的一大创新之处，就是为在 Java 语言进行函数式编程提供了可能，由此，Stream （流） API 应运而生。这里所说的“流”并不是指 I/O 流，而是一种数据流动的管道。举个例子，现在有一个包含 10000 个数字的 <code>int</code> 数组：</p>\n<pre><code class=\"language-java\">int[] array = new int[10000];\n</code></pre>\n<p>我想找出该数组中所有数字大于 5000 的数字，然后让他们加一个不大于 500 的随机数，最后求和。在不使用 Stream API 的情况下我们会这么写：</p>\n<pre><code class=\"language-java\">public int sumRandomNumber(int[] array, Random random){\n        int rst = 0;\n        for (int i : array) {\n            if (i &gt; 5000) {\n                rst += i + random.nextInt(500);\n            }\n        }\n        return rst;\n    }\n</code></pre>\n<p>但如果有了 Stream API ，只需要一行代码就可以解决：</p>\n<pre><code class=\"language-java\">public int sumRandomNumberWithStreamAPI(int[] array, Random random) {\n        return Arrays.stream(array).filter(i -&gt; i &gt; 5000).map(i -&gt; i + random.nextInt(500)).sum();\n    }\n</code></pre>\n<p>在上述代码中，我们通过调用 <code>Arrays.stream</code> 方法将 <code>array</code> 转换为一个 <code>IntStream</code> 流对象，然后顺次调用 <code>filter</code> 和 <code>map</code> 流中间方法，过滤和映射数据，最终调用 <code>sum</code> 流终结方法，获得求和结果。</p>\n<p>一种特定类型的数据经过流中间方法的加工处理，最终经过流终结方法收集为我们想要的形式，这极大地提高了开发效率，而在以前的 Java 中，想要达成这样的操作，会使代码变得极度复杂。</p>\n<h2>Project Loom：Java 迈向现代化的第一步</h2>\n<p>相信各位对“Coroutine （协程）”这个名词一定不陌生，被称为“轻量级线程”的它，在 I/O 密集型的应用程序开发领域可谓是如日中天。所谓“协程”，便是一种用户态的线程，它们构建于线程之上，由用户程序负责调度，而不是操作系统。比起原生的操作系统线程，他更轻量，而比起 Event Loop （事件循环）的解决方案，它又能保证对用户程序足够透明，降低开发过程中的心智负担。</p>\n<p>许多现代语言都配备了协程的原生支持，尽管它们各自的实现方式并不相同，例如 Go 的 <code>Goroutine</code>，Kotlin 的 <code>Kotlin Coroutines</code> 或是 C++ 20 的 <code>Coroutines</code>。在早期版本的 Java 中，其实有一个名为“Green thread （绿色线程）”的协程实现，但因为各种原因，最终被替换回了现在的操作系统线程。</p>\n<p>但是我们确实需要协程，于是 2017 年，Project Loom 应运而生，它的使命就是为 Java 提供自己的有栈协程实现，早期被称为“Fiber （纤程）”，后被称为“Virtual thread （虚拟线程）”，经过两个大版本的预览，其终于在 Java 21 中正式推出，这意味着 Java 平台也拥有了自己的原生协程实现。</p>\n<p>于是现在，你可以通过 Thread 对象的静态工厂方法 <code>ofVirtual</code> 创建一个虚拟线程:</p>\n<pre><code class=\"language-java\">Thread.ofVirtual().start(()-&gt;{\n\t// some heavy IO stuff\n});\n</code></pre>\n<p>就是这么简单，如果你在用 Spring Boot 3 ，只需要一行配置便可以在你的项目中启用虚拟线程支持：</p>\n<pre><code class=\"language-properties\">spring.threads.virtual.enabled=true\n</code></pre>\n<p>很简单对不？现在就去试试看吧，我保证带来的性能提升是立竿见影的。</p>\n<p>当然有关并发编程，另一个绕不开的话题便是异步编程了，Java 目前原生的异步编程由 <code>Future</code> 等对象支持，用起来不能说十分好用，只能说味同嚼蜡。在 Java 19 引入的 Structured Concurrency （结构化并发）事实上在一定程度上为异步编程提供了更好的解决方案，篇幅所限，在这里我们也不再展开。</p>\n<h2>Project Panama：外地人向本地人的妥协</h2>\n<p>长期以来，Java 一直以“一次编写，到处运行”作为自己的卖点，然而很不幸的是，Java 没能向开发者提供所有他们想要的原材料，因此，开发者们决定自己做，最终，在各种 JNI 函数和 Unsafe 调用的狂轰滥炸下，Java 最终还是变成了“一次编写，到处调试”的样子。</p>\n<p>JNI 好用吗？我相信没人会说好用，不然也不可能会有 JNA 一类的库出现，JNI 看似提供了 Java 向 native 调用的接口，但实际上它完全不够灵活，无法在运行时根据程序的需要动态的链接不同的函数。自 Java 1.1 引入 JNI 开始，这个东西就基本没什么变化，大家只能捏着鼻子用这样一套并不好用的东西，或者只能叹叹气，然后另寻他法。</p>\n<p>再回过头来看看 Unsafe ，在过去版本的 Java 中，管理堆外内存是非常复杂且危险的，尤其是当我们通过 hacky 的方式获取 <code>sun.misc.Unsafe</code> 类实例，并使用其中的 <code>allocateMemory</code> 方法来分配堆外内存时。这意味着，我们需要手动管理这些堆外内存的分配和释放，一不小心，就可能造成 JVM 虚拟机和 GC 无法处理的内存泄漏。</p>\n<p>有些人可能会说：JVM 本来就不希望你使用堆外内存，你为什么要这么用，这不是自找没趣吗？但是很遗憾的是，有时要想获得高性能的数据吞吐或是确保数据的一致性，我们不得不这么做，例如在 Java 中使用 <code>mmap</code>, CAS ，或是设置内存屏障。在 Java 8 ，如果你想设置一个操作系统级别的重量级锁，你可以使用 <code>LockSupport.park</code>；自 Java 9 开始，如果你想对一个对象中的字段 CAS 写入，则可以用 <code>VarHandle.compareAndSet</code> 方法；但是其他 JVM 未能提供的操作，也许你只能像使用 JNI 一样，绕一个大圈，或是看看社区上有没有已经做好的，也许可能充满各种漏洞的小玩具。</p>\n<p>但是事情还是需要解决的，最终这场争端以 Java 这个外地人向本地人的妥协而告终：Project Panama 应运而生。经过三个大版本的预览，Project Panama 的一个重要特性，The Foreign Function &amp; Memory (FFM) API 终于在 Java 22 正式落地。FFM API 有什么用？首先，它可以提供灵活的本地库访问：</p>\n<pre><code class=\"language-java\">Linker linker = Linker.nativeLinker();\nSymbolLookup stdlib = linker.defaultLookup();\nMethodHandle strlen = linker.downcallHandle(\n    stdlib.find(\"strlen\").orElseThrow(),\n    FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)\n);\n\ntry (Arena arena = Arena.ofConfined()) {\n    MemorySegment cString = arena.allocateFrom(\"Hello\");\n    long len = (long)strlen.invokeExact(cString); // 5\n}\n</code></pre>\n<p>上述代码创建了一个操作系统标准库的链接器，在其中查找 <code>strlen</code> 函数并以一个从 JVM 创建的堆外字符串作为参数执行，获取结果。在这个过程中，还需要告诉 JVM 函数和参数的内存布局，以便 JVM 可以正确传入他们。</p>\n<p>接下来，FFM API 向我们提供了更适合 Java 宝宝的堆外内存 API ，Arena ，你可以通过这种方式创建一个会自动被 GC 清理的堆外内存：</p>\n<pre><code class=\"language-java\">MemorySegment segment = Arena.ofAuto().allocate(100, 1);\n...\nsegment = null; // the segment region becomes available for deallocation after this point\n</code></pre>\n<p>或者，你可以直接创建一个基于作用域的堆外内存，并使用 <code>try-with-resource</code> 语法包裹，只要离开 <code>try</code> 作用域，则分配的堆外内存会被自动释放：</p>\n<pre><code class=\"language-java\">MemorySegment segment = null;\ntry (Arena arena = Arena.ofConfined()) {\n    segment = arena.allocate(100);\n    ...\n} // segment region deallocated here\nsegment.get(ValueLayout.JAVA_BYTE, 0); // throws IllegalStateException\n</code></pre>\n<p>别忘了 <code>mmap</code>，现在 FFM API 可以直接提供这种支持，只需要调用 <code>FileChannel.map</code> 方法即可：</p>\n<pre><code class=\"language-java\">Arena arena = Arena.ofAuto();\ntry {\n    try (FileChannel channel = FileChannel.open(Path.of(\"large_file\"), StandardOpenOption.READ)) {\n        MemorySegment segment = channel.map(FileChannel.MapMode.READ_ONLY, 0, FILE_SIZE, arena);\n        // use segment in your way\n    }\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n</code></pre>\n<p>是不是简简又单单呢？有了 FFM API 这把瑞士军刀，相信以后 Java 能做的事情会更有趣和疯狂。</p>\n<h2>Project Valhalla：走向未来</h2>\n<p>至此，我们已经介绍完了 Java 走向现代化三座大山中已经落地的前两座，如你所见的是，他们每一个都充满诱惑，十分大胆，令 Java 焕发新生，但是 Project Valhalla 将带给我们的，比前面我讲过的那些特性更加疯狂，更加颠覆：为 Java 引入值类型对象，补上长久以来 Java 泛型编程的缺陷，并为 JVM 虚拟机提供运行时可见的泛型参数。</p>\n<p>让我们先来回忆一下泛型的前世今生：泛型于 Java 1.5 被首次引入，其更官方、也更直观的名称应该是 Parameterized Type （参数化类型），其允许将类型作为类或函数的参数提供，以便于更好的进行类型检查或是根据不同的泛型特化代码实现，然而后者并不被 Java 泛型所支持，因为 Java 泛型采用的方案于 C++, Go, Rust 这些语言的泛型方案有本质不同：Java 的泛型只是编译器语法糖，在运行时并没有影响代码执行，这意味着，当你在 C++ 中使用 <code>Vector&lt;bool&gt;</code> 和 <code>Vector&lt;int&gt;</code> 时，C++ 编译器事实上会生产两个不同版本的 <code>Vector</code> 类（这也是其名称“模板”的由来），但 Java 并不会改变这一点，<code>List&lt;Boolean&gt;</code> 和 <code>List&lt;Integer&gt;</code> 和其未泛化原始类型 <code>List</code> 没有任何差别，编译器会在需要提供或返回泛型参数时帮你做类型安全检查或自动类型转换，而 JVM 不会感知到泛型的存在。</p>\n<p>泛化泛型和具化泛型的争端从未停止，本文也无心讨论此两者之间各自的优劣，但是不可否认是，泛化泛型确实为 Java 引入了一个难以逾越的语法鸿沟：那就是参数化类型无法接受基本数据类型作为参数，这意味着在 C# 程序员严重看起来十分正常的代码：</p>\n<pre><code class=\"language-c#\">List&lt;int&gt; list = new List&lt;&gt;();\n</code></pre>\n<p>在 Java 中是不可能的。而长久以来，Java 程序员只能被迫在需要将基本数据类型放入集合的场景下进退两难：要么把 <code>int</code> 装箱成 <code>Integer</code>，忍受额外的对象创建开销；要么自行构建，或者使用各种工具库提供的特化集合类型（例如 <code>IntArrayList</code>, <code>DoubleArrayList</code> 等）。而事实上，这种语法鸿沟在 Java 中由来已久，例如 <code>switch</code> 语句不支持 <code>double</code> 等类型，<code>instanceof</code> 关键字不支持针对基本数据类型的模式匹配等，颇令新手疑惑，好在在最近的版本（ Java 23 ）中，<a href=\"https://openjdk.org/jeps/455\" rel=\"nofollow\">这些问题都逐步得到完善</a>，进入预览的流程。</p>\n<p>再回过头来看看基本数据类型的装箱机制，这实际上是十分不明智的，因为基本数据类型这种可能被程序大量使用的数据，他们本应将其数值直接存储到内存中，而不是被包装一个含有比他们实际内容更为复杂的对象和对象头，这无疑增加了系统的内存压力。而参数化类型对基本数据类型的缺位更是加剧了这一问题。</p>\n<p>为此，Project Valhalla 横空出世，直指这些痛点问题，并推出了它们的解决方案：值类型和通用泛型。</p>\n<p>在未来的 Java 版本中，我们将可以通过 <code>value class</code> 标识创建一个值类型类：</p>\n<pre><code class=\"language-java\">value record Color(byte red, byte green, byte blue) {} // 值记录类型\n</code></pre>\n<p>这种类型没有对象头，其 <code>hashCode</code> 直接据其所含字段计算，这同时也意味着，对值类型进行 <code>==</code> 比较将会比较其值，而不是其地址。在未来，所有的基本数据类型包装类都会被升级为这种值类型。而原本的类型将会被称为 Identity class ，意为具有身份的类型。</p>\n<p>而通用泛型（这是一个早前叫法，但我觉得放到这里更直观，所以接着沿用下来）将允许我们在未来在泛型中直接使用基本数据类型作为泛型参数，而这种实现有可能依然是通过自动拆装箱实现的。</p>\n<p>如果你恰巧用过 Java 16 及以上的版本，你可能会发现有一个新特性和上述特性有点类似，那就是 Record （记录）类型，该特性允许你通过简单的语法创建一个不可变的 POJO 对象，并为其实现 <code>equals</code>/<code>hashCode</code>/<code>toString</code> 方法和构造函数，而不必由你手动实现，或是使用额外的 <code>@lombok.Data</code> 和 <code>@lombok.AllArgsConstructor</code>注解：</p>\n<pre><code class=\"language-java\">record Point(int x, int y) { } // 通过 new Point(0, 0) 构造，通过 point.x()/point.y() 访问\n</code></pre>\n<p>但实际上，record 和 value class 是有本质区别的。Record 本质上还是一个对象，他依然是一个特殊的语法糖，并没有改变对象的本质；而 value class 则彻底颠覆了 Java 原有的对象模型。</p>\n<p>除此之外，Project Valhalla 还有一些很有意思的提案，例如为 JVM 添加可 null 和非 null 类型，就将 C# 和 Kotlin 所做的那样；亦或者在运行时保留泛型参数，提供特化类型的实现等。</p>\n<p>最后要说的是，Project Valhalla 的相关提案仍在不断更新，早在草案时期，相关提案就已被推翻重置了多次，因此对于该提案的相关描述在未来可能会是不准确的，希望读者悉知。</p>\n<h2>引用</h2>\n<ul>\n<li>\n<p><a href=\"https://openjdk.org/jeps/444\" rel=\"nofollow\">JEP 444: Virtual Threads (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/454\" rel=\"nofollow\">JEP 454: Foreign Function &amp; Memory API (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/471\" rel=\"nofollow\">JEP 471: Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/package-summary.html\" rel=\"nofollow\">java.lang.foreign (Java SE 22 &amp; JDK 22) (oracle.com)</a></p>\n</li>\n<li>\n<p><a href=\"https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/foreign/Arena.html\" rel=\"nofollow\">Arena (Java SE 22 &amp; JDK 22) (oracle.com)</a></p>\n</li>\n<li>\n<p><a href=\"https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode,long,long)\" rel=\"nofollow\">FileChannel (Java SE 22 &amp; JDK 22) (oracle.com)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/projects/valhalla/\" rel=\"nofollow\">Project Valhalla (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/395\" rel=\"nofollow\">JEP 395: Records (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/401\" rel=\"nofollow\">JEP 401: Value Classes and Objects (Preview) (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/402\" rel=\"nofollow\">JEP 402: Enhanced Primitive Boxing (Preview) (openjdk.org)</a></p>\n</li>\n<li>\n<p><a href=\"https://openjdk.org/jeps/455\" rel=\"nofollow\">JEP 455: Primitive Types in Patterns, instanceof, and switch (Preview) (openjdk.org)</a></p>\n</li>\n</ul>\n", "last_modified": 1717247767, "replies": 30, "id": 1046015}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/6e27/13a6/557_large.png?m=1608969785", "name": "life", "avatar_normal": "https://cdn.v2ex.com/navatar/6e27/13a6/557_normal.png?m=1608969785", "title": "生活", "url": "https://www.v2ex.com/go/life", "topics": 5905, "footer": "", "header": "生活中的技术讨论", "title_alternative": "Life", "avatar_mini": "https://cdn.v2ex.com/navatar/6e27/13a6/557_mini.png?m=1608969785", "stars": 1436, "aliases": [], "root": false, "id": 557, "parent_node_name": ""}, "member": {"id": 462723, "username": "Marszm", "url": "https://www.v2ex.com/u/Marszm", "website": null, "twitter": null, "psn": null, "github": null, "btc": null, "location": null, "tagline": null, "bio": null, "avatar_mini": "https://cdn.v2ex.com/avatar/a9ed/1104/462723_mini.png?m=1713150066", "avatar_normal": "https://cdn.v2ex.com/avatar/a9ed/1104/462723_normal.png?m=1713150066", "avatar_large": "https://cdn.v2ex.com/avatar/a9ed/1104/462723_large.png?m=1713150066", "avatar_xlarge": "https://cdn.v2ex.com/avatar/a9ed/1104/462723_xlarge.png?m=1713150066", "created": 1577953337, "last_modified": 1713150066}, "last_reply_by": "phrack", "last_touched": 1717323883, "title": "国内的信息泄露问题是真严重", "url": "https://www.v2ex.com/t/1046100", "created": 1717304531, "deleted": 0, "content": "今天遇到的事情有感，\r\n家里女票为了薅羊毛省钱，去京东搞了个以旧换新，Apple 耳机。今天她跑出去看电影了，我来签收，好家伙，来了个爱回收的，各种信息都要录入，最后还姓名+身份证+人脸识别。我真是服了，这都全要素齐备了，整这么多你这公司是想造反啊，还是给我办网贷啊，还是要给我整个数字人啊。\r\n\r\n目前有人脸识别的地方我都非常谨慎，也就政府网站和支付宝银行认证过。其他坚决不搞，没想到遇到这么一出，这都不禁让我想起来阿拉丁神灯那个故事，家里人把灯给卖了。\r\n\r\n都没人管管的。", "content_rendered": "<p>今天遇到的事情有感，\n家里女票为了薅羊毛省钱，去京东搞了个以旧换新，Apple 耳机。今天她跑出去看电影了，我来签收，好家伙，来了个爱回收的，各种信息都要录入，最后还姓名+身份证+人脸识别。我真是服了，这都全要素齐备了，整这么多你这公司是想造反啊，还是给我办网贷啊，还是要给我整个数字人啊。</p>\n<p>目前有人脸识别的地方我都非常谨慎，也就政府网站和支付宝银行认证过。其他坚决不搞，没想到遇到这么一出，这都不禁让我想起来阿拉丁神灯那个故事，家里人把灯给卖了。</p>\n<p>都没人管管的。</p>\n", "last_modified": 1717304663, "replies": 29, "id": 1046100}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/3cef/96dc/949_large.png?m=1614702882", "name": "nas", "avatar_normal": "https://cdn.v2ex.com/navatar/3cef/96dc/949_normal.png?m=1614702882", "title": "NAS", "url": "https://www.v2ex.com/go/nas", "topics": 1969, "footer": "", "header": "关于网络存储设备的讨论", "title_alternative": "NAS", "avatar_mini": "https://cdn.v2ex.com/navatar/3cef/96dc/949_mini.png?m=1614702882", "stars": 2193, "aliases": [], "root": false, "id": 949, "parent_node_name": "hardware"}, "member": {"id": 76564, "username": "sldaniel", "url": "https://www.v2ex.com/u/sldaniel", "website": "", "twitter": "", "psn": "", "github": "", "btc": "", "location": "", "tagline": "", "bio": "", "avatar_mini": "https://cdn.v2ex.com/gravatar/3ce1307c08fc447d8528126665f2f43e?s=24&d=retro", "avatar_normal": "https://cdn.v2ex.com/gravatar/3ce1307c08fc447d8528126665f2f43e?s=48&d=retro", "avatar_large": "https://cdn.v2ex.com/gravatar/3ce1307c08fc447d8528126665f2f43e?s=73&d=retro", "created": 1412917305, "last_modified": 1705061854}, "last_reply_by": "Jasmine2016", "last_touched": 1717268693, "title": "有没有什么低成本的单盘位 NAS 推荐", "url": "https://www.v2ex.com/t/1046010", "created": 1717246006, "deleted": 0, "content": "arm 平台的是不是能便宜点\r\n\r\n主要用来当异地备份的目地的:\r\n\r\n1.支持 wireguard 和 webdav 就行,这俩应该不难,能装 linux 就行,况且都有 go 版本的二进制包.\r\n\r\n2.带盘位;用 usb 硬盘盒之类的方式容易坏硬盘,供电也不行.\r\n\r\n3.不要太大\r\n\r\n4.支持 docker 加分,非必须\r\n\r\n最便宜的现成方案有什么推荐吗?", "content_rendered": "<p>arm 平台的是不是能便宜点</p>\n<p>主要用来当异地备份的目地的:</p>\n<p>1.支持 wireguard 和 webdav 就行,这俩应该不难,能装 linux 就行,况且都有 go 版本的二进制包.</p>\n<p>2.带盘位;用 usb 硬盘盒之类的方式容易坏硬盘,供电也不行.</p>\n<p>3.不要太大</p>\n<p>4.支持 docker 加分,非必须</p>\n<p>最便宜的现成方案有什么推荐吗?</p>\n", "last_modified": 1717292661, "replies": 25, "id": 1046010}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_large.png?m=1700771269", "name": "programmer", "avatar_normal": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_normal.png?m=1700771269", "title": "程序员", "url": "https://www.v2ex.com/go/programmer", "topics": 62980, "footer": "", "header": "While code monkeys are not eating bananas, they're coding.", "title_alternative": "Programmer", "avatar_mini": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_mini.png?m=1700771269", "stars": 8977, "aliases": [], "root": false, "id": 300, "parent_node_name": "computer"}, "member": {"id": 314039, "username": "jqtmviyu", "url": "https://www.v2ex.com/u/jqtmviyu", "website": "", "twitter": null, "psn": null, "github": null, "btc": null, "location": "", "tagline": "", "bio": "", "avatar_mini": "https://cdn.v2ex.com/avatar/e464/c332/314039_mini.png?m=1717281295", "avatar_normal": "https://cdn.v2ex.com/avatar/e464/c332/314039_normal.png?m=1717281295", "avatar_large": "https://cdn.v2ex.com/avatar/e464/c332/314039_large.png?m=1717281295", "avatar_xlarge": "https://cdn.v2ex.com/avatar/e464/c332/314039_xlarge.png?m=1717281295", "avatar_xxlarge": "https://cdn.v2ex.com/avatar/e464/c332/314039_xlarge.png?m=1717281295", "created": 1525360947, "last_modified": 1717281295}, "last_reply_by": "wangxin13g", "last_touched": 1717323457, "title": "有人了解麒麟 9000c 吗?", "url": "https://www.v2ex.com/t/1046056", "created": 1717287100, "deleted": 0, "content": "为啥会老想着把手机/服务器芯片搬上 pc 平台.\r\n\r\n网上说 3A6000 性能接近 10 代 i3, 再怎么样都比手机芯片更合适吧", "content_rendered": "<p>为啥会老想着把手机/服务器芯片搬上 pc 平台.</p>\n<p>网上说 3A6000 性能接近 10 代 i3, 再怎么样都比手机芯片更合适吧</p>\n", "last_modified": 1717287100, "replies": 24, "id": 1046056}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/6cdd/60ea/184_large.png?m=1630643913", "name": "apple", "avatar_normal": "https://cdn.v2ex.com/navatar/6cdd/60ea/184_normal.png?m=1630643913", "title": "Apple", "url": "https://www.v2ex.com/go/apple", "topics": 25636, "footer": "", "header": "设计了 <a href=\"/go/watch\">Apple Watch</a>，<a href=\"/go/ipad\">iPad</a>，<a href=\"/go/iphone\">iPhone</a>，<a href=\"/go/imac\">iMac</a> 及 <a href=\"/go/mbp\">MacBook Pro</a> 等电子产品的美国公司。", "title_alternative": "Apple", "avatar_mini": "https://cdn.v2ex.com/navatar/6cdd/60ea/184_mini.png?m=1630643913", "stars": 2942, "aliases": [], "root": false, "id": 184, "parent_node_name": "hardware"}, "member": {"id": 406260, "username": "yushi17", "url": "https://www.v2ex.com/u/yushi17", "website": "yu-shi.github.io", "twitter": "", "psn": "", "github": "", "btc": "", "location": "Beijing", "tagline": "", "bio": "", "avatar_mini": "https://cdn.v2ex.com/avatar/1bf3/d3d6/406260_mini.png?m=1715792508", "avatar_normal": "https://cdn.v2ex.com/avatar/1bf3/d3d6/406260_normal.png?m=1715792508", "avatar_large": "https://cdn.v2ex.com/avatar/1bf3/d3d6/406260_large.png?m=1715792508", "created": 1556208091, "last_modified": 1715792508}, "last_reply_by": "KoreaFish", "last_touched": 1717324909, "title": "电商平台购买苹果产品靠谱不", "url": "https://www.v2ex.com/t/1046095", "created": 1717301343, "deleted": 0, "content": "如题，自己以前一直都是在苹果官网购买苹果产品的，现在看到电商平台买 iPhone 比官网便宜很多，比如说京东上“Apple 产品京东自营旗舰店”iPhone 15 Pro Max 只要 7749 元，比官网 9999 元便宜 2250 元，想问下靠谱不，有什么注意事项之类", "content_rendered": "<p>如题，自己以前一直都是在苹果官网购买苹果产品的，现在看到电商平台买 iPhone 比官网便宜很多，比如说京东上“Apple 产品京东自营旗舰店”iPhone 15 Pro Max 只要 7749 元，比官网 9999 元便宜 2250 元，想问下靠谱不，有什么注意事项之类</p>\n", "last_modified": 1717301343, "replies": 23, "id": 1046095}]