[{"node": {"avatar_large": "https://cdn.v2ex.com/navatar/a5e0/0132/146_large.png?m=1594135486", "name": "js", "avatar_normal": "https://cdn.v2ex.com/navatar/a5e0/0132/146_normal.png?m=1594135486", "title": "JavaScript", "url": "https://www.v2ex.com/go/js", "topics": 2570, "footer": "", "header": "JavaScript (sometimes abbreviated JS) is a prototype-based scripting language that is dynamic, weakly typed and has first-class functions.", "title_alternative": "JavaScript", "avatar_mini": "https://cdn.v2ex.com/navatar/a5e0/0132/146_mini.png?m=1594135486", "stars": 2592, "aliases": [], "root": false, "id": 146, "parent_node_name": "programming"}, "member": {"username": "BoringTu", "website": "https://boringtu.com", "github": "boringtu", "psn": "", "avatar_normal": "https://cdn.v2ex.com/gravatar/2f6cc0bdcaeb803a4c46e836f15b7c94?s=24&d=retro", "bio": "", "url": "https://www.v2ex.com/u/BoringTu", "tagline": "", "twitter": "", "created": 1523427136, "avatar_large": "https://cdn.v2ex.com/gravatar/2f6cc0bdcaeb803a4c46e836f15b7c94?s=24&d=retro", "avatar_mini": "https://cdn.v2ex.com/gravatar/2f6cc0bdcaeb803a4c46e836f15b7c94?s=24&d=retro", "location": "", "btc": "", "id": 307764}, "last_reply_by": "nanxiaobei", "last_touched": 1620313819, "title": "为什么你们要选择 TypeScript？", "url": "https://www.v2ex.com/t/775169", "created": 1620283503, "content": "我只是不明白为啥这么多人会选择 ts ？理由是啥啊？ ts 出来的那年我就关注了，但所有的理由在我看来都是莫名其妙的观点，但这些年怎么还用的人越来越多了？\r\n咱就说脑回路很神奇的把本身弱类型为优势的 JavaScript，套了一层强类型的壳的这步操作我就看不懂了，这是图啥呢？这样代码写着不难受么？那你直接用 Java 写然后编译成 JavaScript 不好么？\r\n网上有很多人说，用 ts 可以减少因类型导致的错误。大哥，你是个程序员，你连自己写的代码是怎么跑的都不知道的话，转行好吗？我十一年的程序员了，js 写了 11 年，js 的其他高级语言我也都研究过，包括 ts，但现在只用 es6 和 coffee2，我怎么就一次都没碰到过我连变量背后的值类型导致的 bug 呢？", "content_rendered": "我只是不明白为啥这么多人会选择 ts ？理由是啥啊？ ts 出来的那年我就关注了，但所有的理由在我看来都是莫名其妙的观点，但这些年怎么还用的人越来越多了？<br />咱就说脑回路很神奇的把本身弱类型为优势的 JavaScript，套了一层强类型的壳的这步操作我就看不懂了，这是图啥呢？这样代码写着不难受么？那你直接用 Java 写然后编译成 JavaScript 不好么？<br />网上有很多人说，用 ts 可以减少因类型导致的错误。大哥，你是个程序员，你连自己写的代码是怎么跑的都不知道的话，转行好吗？我十一年的程序员了，js 写了 11 年，js 的其他高级语言我也都研究过，包括 ts，但现在只用 es6 和 coffee2，我怎么就一次都没碰到过我连变量背后的值类型导致的 bug 呢？", "last_modified": 1620283503, "replies": 169, "id": 775169}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/b789/2fb3/937_large.png?m=1584298330", "name": "zhihu", "avatar_normal": "https://cdn.v2ex.com/navatar/b789/2fb3/937_normal.png?m=1584298330", "title": "知乎", "url": "https://www.v2ex.com/go/zhihu", "topics": 271, "footer": "", "header": "知乎创建于 2010 年，是一个用户产生内容的问答社区", "title_alternative": "Zhihu", "avatar_mini": "https://cdn.v2ex.com/navatar/b789/2fb3/937_mini.png?m=1584298330", "stars": 81, "aliases": [], "root": false, "id": 937, "parent_node_name": "internet"}, "member": {"username": "Cassano", "website": null, "github": null, "psn": null, "avatar_normal": "https://cdn.v2ex.com/avatar/020c/daac/461815_mini.png?m=1577460505", "bio": null, "url": "https://www.v2ex.com/u/Cassano", "tagline": null, "twitter": null, "created": 1577460265, "avatar_large": "https://cdn.v2ex.com/avatar/020c/daac/461815_mini.png?m=1577460505", "avatar_mini": "https://cdn.v2ex.com/avatar/020c/daac/461815_mini.png?m=1577460505", "location": null, "btc": null, "id": 461815}, "last_reply_by": "OceanSea", "last_touched": 1620306738, "title": "为什么现在到处都在说拉垮，而且什么都能拉垮？还有什么不能拉垮的么？我觉得现在有些过度使用这个词汇了", "url": "https://www.v2ex.com/t/775084", "created": 1620266457, "content": "", "content_rendered": "", "last_modified": 1620276475, "replies": 67, "id": 775084}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_large.png?m=1618811339", "name": "qna", "avatar_normal": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_normal.png?m=1618811339", "title": "问与答", "url": "https://www.v2ex.com/go/qna", "topics": 172122, "footer": "", "header": "一个更好的世界需要你持续地提出好问题。", "title_alternative": "Questions and Answers", "avatar_mini": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_mini.png?m=1618811339", "stars": 3219, "aliases": [], "root": false, "id": 12, "parent_node_name": "v2ex"}, "member": {"username": "Pogbag", "website": "shua1zh.github.io", "github": "", "psn": "", "avatar_normal": "https://cdn.v2ex.com/avatar/a49b/0fdd/300244_mini.png?m=1609399441", "bio": "", "url": "https://www.v2ex.com/u/Pogbag", "tagline": "", "twitter": "", "created": 1521078466, "avatar_large": "https://cdn.v2ex.com/avatar/a49b/0fdd/300244_mini.png?m=1609399441", "avatar_mini": "https://cdn.v2ex.com/avatar/a49b/0fdd/300244_mini.png?m=1609399441", "location": "", "btc": "", "id": 300244}, "last_reply_by": "chenmaoxin", "last_touched": 1620317263, "title": "你们的 NAS 上都跑了什么服务", "url": "https://www.v2ex.com/t/775071", "created": 1620264103, "content": "机型：DS220+/10G RAM/4T+1T HDD\r\n系统：DSM 6.2.4\r\n\r\n下载：download station/玩物下载 /qBittorent\r\n\r\n影音：Emby/tinyMediaManager/AVDC\r\n\r\n同步：Cloud Sync 同步百度网盘\r\n\r\nDocker：chrome 浏览器 访问内网路由器用的\r\n\r\n虚拟机：装了 win7 卡的要死 鼠标掉帧\r\n\r\n求推荐一些好玩的", "content_rendered": "<p>机型：DS220+/10G RAM/4T+1T HDD\n系统：DSM 6.2.4</p>\n<p>下载：download station/玩物下载 /qBittorent</p>\n<p>影音：Emby/tinyMediaManager/AVDC</p>\n<p>同步：Cloud Sync 同步百度网盘</p>\n<p>Docker：chrome 浏览器 访问内网路由器用的</p>\n<p>虚拟机：装了 win7 卡的要死 鼠标掉帧</p>\n<p>求推荐一些好玩的</p>\n", "last_modified": 1620264103, "replies": 66, "id": 775071}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_large.png?m=1620107083", "name": "programmer", "avatar_normal": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_normal.png?m=1620107083", "title": "程序员", "url": "https://www.v2ex.com/go/programmer", "topics": 44369, "footer": "", "header": "While code monkeys are not eating bananas, they're coding.", "title_alternative": "Programmer", "avatar_mini": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_mini.png?m=1620107083", "stars": 7362, "aliases": [], "root": false, "id": 300, "parent_node_name": "computer"}, "member": {"username": "polyang", "website": "", "github": null, "psn": null, "avatar_normal": "https://cdn.v2ex.com/avatar/8bcb/c1d0/510643_mini.png?m=1601433658", "bio": "", "url": "https://www.v2ex.com/u/polyang", "tagline": "", "twitter": null, "created": 1601393887, "avatar_large": "https://cdn.v2ex.com/avatar/8bcb/c1d0/510643_mini.png?m=1601433658", "avatar_mini": "https://cdn.v2ex.com/avatar/8bcb/c1d0/510643_mini.png?m=1601433658", "location": "", "btc": null, "id": 510643}, "last_reply_by": "yousabuk", "last_touched": 1620311663, "title": "各位买 nas 一般用来干嘛？", "url": "https://www.v2ex.com/t/775159", "created": 1620281550, "content": "看 V 站挺多人提到 nas，很好奇一般买来干嘛。\r\n\r\n还有一般在什么网站买？", "content_rendered": "看 V 站挺多人提到 nas，很好奇一般买来干嘛。<br /><br />还有一般在什么网站买？", "last_modified": 1620281550, "replies": 52, "id": 775159}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_large.png?m=1618811339", "name": "qna", "avatar_normal": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_normal.png?m=1618811339", "title": "问与答", "url": "https://www.v2ex.com/go/qna", "topics": 172122, "footer": "", "header": "一个更好的世界需要你持续地提出好问题。", "title_alternative": "Questions and Answers", "avatar_mini": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_mini.png?m=1618811339", "stars": 3219, "aliases": [], "root": false, "id": 12, "parent_node_name": "v2ex"}, "member": {"username": "kim886", "website": "", "github": null, "psn": null, "avatar_normal": "https://cdn.v2ex.com/avatar/d01e/151b/525984_mini.png?m=1619489001", "bio": "", "url": "https://www.v2ex.com/u/kim886", "tagline": "", "twitter": null, "created": 1609204000, "avatar_large": "https://cdn.v2ex.com/avatar/d01e/151b/525984_mini.png?m=1619489001", "avatar_mini": "https://cdn.v2ex.com/avatar/d01e/151b/525984_mini.png?m=1619489001", "location": "", "btc": null, "id": 525984}, "last_reply_by": "18758036350", "last_touched": 1620312071, "title": "明明工作强度不高，睡眠也充足，可为什么还是感觉累呢？", "url": "https://www.v2ex.com/t/775166", "created": 1620282722, "content": "工作时间 966，晚上 11 点左右睡觉，早上 8 点起床，下班吃了饭还会去散步，可每天还是感觉好累啊，特别是下午和晚上。\r\n\r\n下了班就啥也不想做，散步还是被女票拉着去的，散步回来洗完澡就躺床上刷头条、玩游戏，制定的学习却计划迟迟没有开始。", "content_rendered": "工作时间 966，晚上 11 点左右睡觉，早上 8 点起床，下班吃了饭还会去散步，可每天还是感觉好累啊，特别是下午和晚上。<br /><br />下了班就啥也不想做，散步还是被女票拉着去的，散步回来洗完澡就躺床上刷头条、玩游戏，制定的学习却计划迟迟没有开始。", "last_modified": 1620282722, "replies": 51, "id": 775166}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_large.png?m=1620107083", "name": "programmer", "avatar_normal": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_normal.png?m=1620107083", "title": "程序员", "url": "https://www.v2ex.com/go/programmer", "topics": 44369, "footer": "", "header": "While code monkeys are not eating bananas, they're coding.", "title_alternative": "Programmer", "avatar_mini": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_mini.png?m=1620107083", "stars": 7362, "aliases": [], "root": false, "id": 300, "parent_node_name": "computer"}, "member": {"username": "waibunleung", "website": null, "github": null, "psn": null, "avatar_normal": "https://cdn.v2ex.com/avatar/dabc/65b9/210792_mini.png?m=1563788897", "bio": null, "url": "https://www.v2ex.com/u/waibunleung", "tagline": null, "twitter": null, "created": 1484371340, "avatar_large": "https://cdn.v2ex.com/avatar/dabc/65b9/210792_mini.png?m=1563788897", "avatar_mini": "https://cdn.v2ex.com/avatar/dabc/65b9/210792_mini.png?m=1563788897", "location": null, "btc": null, "id": 210792}, "last_reply_by": "charlie21", "last_touched": 1620316017, "title": "DAO 层和 ORM，能区分，但又不完全能区分，我裂开了", "url": "https://www.v2ex.com/t/775162", "created": 1620282174, "content": "desc：是这样的，小弟从 php 转到 go 一个月时间不够，项目的目录结构需要自己搭建。于是就找网上的项目组织目录参考，发现有一部分目录结构里有 dao 层的分层概念。这个在 java 里面比较常见，在 php 中用得比较多的是 orm，不知道 go 中是不是也适合这样搞。\r\n\r\n于是引起了我一顿梳理 dao 和 orm 之间的关系。但仍有如下疑问：\r\n\r\n1. 究竟项目使用了 orm 之后，还需不需要再分一层 DAO 层出来？如果要分，此时的 DAO 层里面写的是什么逻辑？求 demo 举例\r\n2. ORM 不是正好替代了 DAO 的角色吗？还是说 DAO 可以通过 ORM 来实现？此时 DAO 层的实现是怎么样的？在 ORM 外面包一层，意义在哪里？\r\n3. 在项目代码分层上(语言无关)，DAO 和 ORM 分别是什么层面上的东西？\r\n\r\n真的纠结了三四天了，每天看完都有不同的结论，求大佬们指点一下你们在项目中是怎么划分的~", "content_rendered": "<p>desc：是这样的，小弟从 php 转到 go 一个月时间不够，项目的目录结构需要自己搭建。于是就找网上的项目组织目录参考，发现有一部分目录结构里有 dao 层的分层概念。这个在 java 里面比较常见，在 php 中用得比较多的是 orm，不知道 go 中是不是也适合这样搞。</p>\n<p>于是引起了我一顿梳理 dao 和 orm 之间的关系。但仍有如下疑问：</p>\n<ol>\n<li>究竟项目使用了 orm 之后，还需不需要再分一层 DAO 层出来？如果要分，此时的 DAO 层里面写的是什么逻辑？求 demo 举例</li>\n<li>ORM 不是正好替代了 DAO 的角色吗？还是说 DAO 可以通过 ORM 来实现？此时 DAO 层的实现是怎么样的？在 ORM 外面包一层，意义在哪里？</li>\n<li>在项目代码分层上(语言无关)，DAO 和 ORM 分别是什么层面上的东西？</li>\n</ol>\n<p>真的纠结了三四天了，每天看完都有不同的结论，求大佬们指点一下你们在项目中是怎么划分的~</p>\n", "last_modified": 1620282174, "replies": 42, "id": 775162}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_large.png?m=1618811339", "name": "qna", "avatar_normal": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_normal.png?m=1618811339", "title": "问与答", "url": "https://www.v2ex.com/go/qna", "topics": 172122, "footer": "", "header": "一个更好的世界需要你持续地提出好问题。", "title_alternative": "Questions and Answers", "avatar_mini": "https://cdn.v2ex.com/navatar/c20a/d4d7/12_mini.png?m=1618811339", "stars": 3219, "aliases": [], "root": false, "id": 12, "parent_node_name": "v2ex"}, "member": {"username": "zjvbqla", "website": "", "github": null, "psn": null, "avatar_normal": "https://cdn.v2ex.com/avatar/5cc7/759d/305333_mini.png?m=1613721293", "bio": "", "url": "https://www.v2ex.com/u/zjvbqla", "tagline": "", "twitter": null, "created": 1522647311, "avatar_large": "https://cdn.v2ex.com/avatar/5cc7/759d/305333_mini.png?m=1613721293", "avatar_mini": "https://cdn.v2ex.com/avatar/5cc7/759d/305333_mini.png?m=1613721293", "location": "", "btc": null, "id": 305333}, "last_reply_by": "jim9606", "last_touched": 1620308503, "title": "有很多视频要备份， macos 下天翼云盘和 onedrive 一言难尽，求备份软件介绍", "url": "https://www.v2ex.com/t/775064", "created": 1620256886, "content": "天翼云盘 macos 客户端连同步也没有，只有上传，且数据很大的时候早上起来一看，不知道怎么就没有数据传输了，按照道理黄金会员一天上限是 200g 啊？搞不懂。\r\n\r\nonedrive office365 家庭版，以前 windows 倒没有遇到什么问题，macos 下老是风火轮，不知道在干嘛？甚至一度我以为我的硬盘坏了，点击进入一些目录显示“正在载入中”，无意中关闭 onedrive 居然好了。\r\n\r\n目前一天大概是 20-30g，预计这个数量还要有所增加，所以很多方案成本太高了，用法是本地保存一点近期使用的，过几天就备份上去。\r\n\r\n记忆中好像有这样一种软件，就是去中心化的，把你的想要备份的文件打成数据碎片存储在不同的用户电脑中。除了用户本人得到的是完整的，其他任何用户得到的全是不完整的数据碎片。\r\n\r\n且无需考虑容量问题。类似的软件叫什么？", "content_rendered": "<p>天翼云盘 macos 客户端连同步也没有，只有上传，且数据很大的时候早上起来一看，不知道怎么就没有数据传输了，按照道理黄金会员一天上限是 200g 啊？搞不懂。</p>\n<p>onedrive office365 家庭版，以前 windows 倒没有遇到什么问题，macos 下老是风火轮，不知道在干嘛？甚至一度我以为我的硬盘坏了，点击进入一些目录显示“正在载入中”，无意中关闭 onedrive 居然好了。</p>\n<p>目前一天大概是 20-30g，预计这个数量还要有所增加，所以很多方案成本太高了，用法是本地保存一点近期使用的，过几天就备份上去。</p>\n<p>记忆中好像有这样一种软件，就是去中心化的，把你的想要备份的文件打成数据碎片存储在不同的用户电脑中。除了用户本人得到的是完整的，其他任何用户得到的全是不完整的数据碎片。</p>\n<p>且无需考虑容量问题。类似的软件叫什么？</p>\n", "last_modified": 1620256886, "replies": 41, "id": 775064}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_large.png?m=1620107083", "name": "programmer", "avatar_normal": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_normal.png?m=1620107083", "title": "程序员", "url": "https://www.v2ex.com/go/programmer", "topics": 44369, "footer": "", "header": "While code monkeys are not eating bananas, they're coding.", "title_alternative": "Programmer", "avatar_mini": "https://cdn.v2ex.com/navatar/94f6/d7e0/300_mini.png?m=1620107083", "stars": 7362, "aliases": [], "root": false, "id": 300, "parent_node_name": "computer"}, "member": {"username": "waruqi", "website": "https://tboox.org", "github": "waruqi", "psn": "", "avatar_normal": "https://cdn.v2ex.com/avatar/d4e1/9685/128521_mini.png?m=1507786719", "bio": "专注于跨平台开发解决方案：\r\n\r\n个人开源项目：https://github.com/waruqi\r\n\r\n个人主页：\r\nhttps://tboox.org\r\n\r\n项目站点：https://xmake.io\r\n\r\nQQ技术交流群: 343118190\r\n\r\n微信公众号：tboox-os", "url": "https://www.v2ex.com/u/waruqi", "tagline": "https://tboox.org", "twitter": "waruqi", "created": 1437630119, "avatar_large": "https://cdn.v2ex.com/avatar/d4e1/9685/128521_mini.png?m=1507786719", "avatar_mini": "https://cdn.v2ex.com/avatar/d4e1/9685/128521_mini.png?m=1507786719", "location": "", "btc": "", "id": 128521}, "last_reply_by": "kios", "last_touched": 1620302557, "title": "C/C++ 构建系统，我用 xmake", "url": "https://www.v2ex.com/t/775065", "created": 1620259117, "content": "### XMake 是什么\r\n\r\n[XMake]( https://github.com/xmake-io/xmake) 是一个基于 Lua 的 现代化 C/C++ 构建系统。\r\n\r\n它的语法简洁易上手，对新手友好，即使完全不会 lua 也能够快速入门，并且完全无任何依赖，轻量，跨平台。\r\n\r\n同时，它也是一个自满足的构建系统，拥有强大的包管理系统，快速的构建引擎。\r\n\r\n相比 Ninja/Scons/Make 作为 Build backend，CMake/Meson 作为 Project Generator，那么 XMake 就是这两者外加一个包管理。\r\n\r\n```\r\nxmake = Build backend + Project Generator + Package Manager\r\n```\r\n\r\n因此，只需要安装一个不到 3M 的 XMake 安装包，你就可以不用再安装其他各种工具，甚至连 make 都不需要安装，也不需要安装 Python 、Java 等重量级的运行时环境，就可以开始您的 C/C++ 开发之旅。\r\n\r\n也许，有人会说，编译器总需要安装的吧。这也不是必须的，因为 XMake 的包管理也支持自动远程拉取需要的各种编译工具链，比如：llvm, Mingw, Android NDK 或者交叉编译工具链。\r\n\r\n### 为什么要做 XMake\r\n\r\n每当在 Reddit 社区跟别人讨论起 XMake，大家总是会拿下面这张图来吐槽。\r\n\r\n![]( https://imgs.xkcd.com/comics/standards.png)\r\n\r\n尽管有些无奈，也被吐槽的有些麻木了，不过我还是想说明下，做 XMake 的初衷，并不是为了分裂 C/C++  生态，相反，XMake 尽可能地复用了现有生态。\r\n\r\n同时也让用户在开发 C/C++ 项目的时候，拥有与其他语言一样的良好体验，比如：Rust/Cargo，Nodejs/Npm, Dlang/Dub，不再为到处找第三包，研究如何移植编译而折腾。\r\n\r\n因此，如果您还不了解 XMake，请不要过早下定论，可以先尝试使用下，或者花点时间看完下文的详细介绍。\r\n\r\n### XMake 的特性和优势\r\n\r\n经常有人问我 XMake 有什么特别之处，相比现有 CMake 、Meson 此类构建工具有什么优势，我为什么要使用 XMake 而不是 CMake ？\r\n\r\n先说特点和优势，XMake 有以下几点：\r\n\r\n- 简洁易学的配置语法，非 DSL\r\n- 强大的包管理，支持语义版本，工具链管理\r\n- 足够轻量，无依赖\r\n- 极速编译，构建速度和 Ninja 一样快\r\n- 简单方便的多平台、工具链切换\r\n- 完善的插件系统\r\n- 灵活的构建规则\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n至于 CMake，毕竟已成事实上的标准，生态完善，功能强大。\r\n\r\n我从没想过让 XMake 去替代它，也替代不了，完全不是一个量级的，但是 CMake 也有许多为人所诟病的短板，比如：语法复杂难懂，包管理支持不完善等等。\r\n\r\n因此使用 XMake 可以作为一种补充，对于那些想要简单快速入门 C/C++ 开发的新手，或者想要更加方便易用的包管理，或者想临时快速写一些短小的测试项目。\r\n\r\nXMake 都可以帮他们提升开发效率，让其更加关注 C/C++ 项目本身，而不是花更多的时间在构建工具和开发环境上。\r\n\r\n下面，我来具体介绍 XMake 的这些主要特性。\r\n\r\n### 语法简洁易上手\r\n\r\nCMake 自己设计一门 DSL 语言用来做项目配置，这对用户来讲提高了学习成本，而且它的语法可读性不是很直观，很容易写出过于复杂的配置脚本，也提高了维护成本。\r\n\r\n而 XMake 复用现有知名的 Lua 语言作为基础，并且其上提供了更加简单直接的配置语法。\r\n\r\nLua 本身就是一门简单轻量的胶水语言，关键字和内置类型就那么几种，看个一篇文章，就能基本入门了，并且相比 DSL，能够从网上更方便的获取到大量相关资料和教程。\r\n\r\n#### 基础语法\r\n\r\n不过，还是有人会吐槽：那不是还得学习 Lua 么？\r\n\r\n其实也不用，XMake 采用了 `描述域` 和 `脚本域` 分离的方式，使得初学者用户在 80% 的情况下，只需要在描述域以更简单直接的方式来配置，完全可以不把它当成 Lua 脚本，例如：\r\n\r\n```lua\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    add_files(\"test/*.c\", \"example/**.cpp\")\r\n```\r\n\r\n如果因为，看着有括号，还是像脚本语言的函数调用，那我们也可以这么写（是否带括号看个人喜好，不过我个人还是建议使用上面的方式）\r\n\r\n```lua\r\ntarget \"test\"\r\n    set_kind \"binary\"\r\n    add_files \"src/*.c\"\r\n    add_files \"test/*.c\"\r\n    add_files \"example/**.cpp\"\r\n```\r\n\r\n我们只需要知道常用配置接口，即使不完全不会 Lua 也能快速配置了。\r\n\r\n我们可以对比下 CMake 的配置：\r\n\r\n```cmake\r\nadd_executable(test \"\")\r\nfile(GLOB SRC_FILES \"src/*.c\")\r\nfile(GLOB TEST_FILES \"test/*.c\")\r\nfile(GLOB_RECURSE EXAMPLE_FILES \"example/*.cpp\")\r\ntarget_sources(test PRIVATE\r\n    ${SRC_FILES}\r\n    ${TEST_FILES}\r\n    ${EXAMPLE_FILES}\r\n)\r\n```\r\n\r\n哪个更直观可读，一目了然。\r\n\r\n#### 条件配置\r\n\r\n如果，你已经初步了解了一些 Lua 等基础知识，比如 `if then` 等条件判断，那么可以进一步做一些条件配置。\r\n\r\n```lua\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/main.c\")\r\n    if is_plat(\"macosx\", \"linux\") then\r\n        add_defines(\"TEST1\", \"TEST2\")\r\n    end\r\n    if is_plat(\"windows\") and is_mode(\"release\") then\r\n        add_cxflags(\"-Ox\", \"-fp:fast\")\r\n    end\r\n```\r\n\r\n继续对比下 CMake 版本配置：\r\n\r\n```cmake\r\nadd_executable(test \"\")\r\nif (APPLE OR LINUX)\r\n    target_compile_definitions(test PRIVATE TEST1 TEST2)\r\nendif()\r\nif (WIN32)\r\n    target_compile_options(test PRIVATE $<$<CONFIG:Release>:-Ox -fp:fast>)\r\nendif()\r\ntarget_sources(test PRIVATE\r\n    src/main.c\r\n)\r\n```\r\n\r\n#### 复杂脚本\r\n\r\n如果你已经晋升为 XMake 的高端玩家，Lua 语法了然于胸，想要更加灵活的定制化配置需要，并且描述域的几行简单配置已经满足不了你的需求。\r\n\r\n那么 XMake 也提供了更加完整的 Lua 脚本定制化能力，你可以写任何复杂的脚本。\r\n\r\n比如在构建之前，对所有源文件进行一些预处理，在构建之后，执行外部 gradle 命令进行后期打包，甚至我们还可以重写内部链接规则，实现深度定制编译，我们可以通过[import]( https://xmake.io/#/zh/manual?id=import) 接口，导入内置的 linker 扩展模块，实现复杂灵活的链接过程。\r\n\r\n```lua\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    before_build_file(function (target, sourcefile)\r\n        io.replace(sourcefile, \"#define HAVE_XXX 1\", \"#define HAVE_XXX 0\")\r\n    end)\r\n    on_link(function (target)\r\n        import(\"core.tool.linker\")\r\n        linker.link(\"binary\", \"cc\", target:objectfiles(), target:targetfile(), {target = target})\r\n    end)\r\n    after_build(function (target)\r\n        if is_plat(\"android\" then\r\n            os.cd(\"android/app\")\r\n            os.exec(\"./gradlew app:assembleDebug\")\r\n        end\r\n    end)\r\n```\r\n\r\n如果换成 CMake，也可以 add_custom_command 里面实现，不过里面似乎只能简单的执行一些批处理命令，没法做各种复杂的逻辑判断，模块加载，自定义配置脚本等等。\r\n\r\n当然，使用 cmake 肯定也能实现上面描述的功能，但绝对不会那么简单。\r\n\r\n如果有熟悉 cmake 的人，也可以尝试帮忙完成下面的配置：\r\n\r\n```cmake\r\nadd_executable(test \"\")\r\nfile(GLOB SRC_FILES \"src/*.c\")\r\nadd_custom_command(TARGET test PRE_BUILD\r\n    -- TODO\r\n    COMMAND echo hello\r\n)\r\nadd_custom_command(TARGET test POST_BUILD\r\n    COMMAND cd android/app\r\n    COMMAND ./gradlew app:assembleDebug\r\n)\r\n-- How can we override link stage?\r\ntarget_sources(test PRIVATE\r\n    ${SRC_FILES}\r\n)\r\n```\r\n\r\n### 强大的包管理\r\n\r\n众所周知，做 C/C++ 相关项目开发，最头大的就是各种依赖包的集成，由于没有像 Rust/Cargo 那样完善的包管理系统。\r\n\r\n因此，我们每次想使用一个第三方库，都需要各种找，研究各种平台的移植编译，还经常遇到各种编译问题，极大耽误了开发者时间，无法集中精力去投入到实际的项目开发中去。\r\n\r\n好不容易当前平台搞定了，换到其他平台，有需要重新折腾一遍依赖包，为了解决这个问题，出现了一些第三方的包管理器，比如 vcpkg/conan/conda 等等，但有些不支持语义版本，有些支持的平台有限，但不管怎样，总算是为解决 C/C++ 库的依赖管理迈进了很大一步。\r\n\r\n但是，光有包管理器，C/C++ 项目中使用它们还是比较麻烦，因为还需要对应构建工具能够很好的对其进行集成支持才行。\r\n\r\n#### CMake 和 Vcpkg\r\n\r\n我们先来看下 CMake 和 Vcpkg 的集成支持：\r\n\r\n```\r\ncmake_minimum_required(VERSION 3.0)\r\nproject(test)\r\nfind_package(unofficial-sqlite3 CONFIG REQUIRED)\r\nadd_executable(main main.cpp)\r\ntarget_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3)\r\n```\r\n\r\n缺点：\r\n\r\n- 还需要额外配置 `-DCMAKE_TOOLCHAIN_FILE=<vcpkg_dir>/scripts/buildsystems/vcpkg.cmake\"`\r\n- 不支持自动安装依赖包，还需要用户手动执行 `vcpkg install xxx` 命令安装\r\n- vcpkg 的语义版本选择不支持 （据说新版本开始支持了）\r\n\r\n#### CMake 和 Conan\r\n\r\n```\r\n```cmake\r\ncmake_minimum_required(VERSION 2.8.12)\r\nproject(Hello)\r\n\r\nadd_definitions(\"-std=c++11\")\r\n\r\ninclude(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)\r\nconan_basic_setup()\r\n\r\nadd_executable(hello hello.cpp)\r\ntarget_link_libraries(hello gtest)\r\n```\r\n\r\nconanfile.txt\r\n\r\n```text\r\n[requires]\r\ngtest/1.10.0\r\n\r\n[generators]\r\ncmake\r\n```\r\n\r\n缺点：\r\n\r\n- 同样，还是需要额外调用 `conan install ..` 来安装包\r\n- 还需要额外配置一个 conanfile.txt 文件去描述包依赖规则\r\n\r\n#### Meson 和 Vcpkg\r\n\r\n我没找到如何在 Meson 中去使用 vcpkg 包，仅仅找到一篇相关的 [Issue #3500]( https://github.com/mesonbuild/meson/issues/3500) 讨论。\r\n\r\n#### Meson 和 Conan\r\n\r\nMeson 似乎还没有对 Conan 进行支持，但是 Conan 官方文档上有解决方案，对齐进行支持，但是很复杂，我是没看会，大家可以自行研究：[https://docs.conan.io/en/latest/reference/build_helpers/meson.html]( https://docs.conan.io/en/latest/reference/build_helpers/meson.html)\r\n\r\n#### XMake 和 Vcpkg\r\n\r\n前面讲了这么多，其他构建工具和包管理的集成，个人感觉用起来很麻烦，而且不同的包管理器，集成方式差别很大，用户想要快速从 Vcpkg 切换到 Conan 包，改动量非常大。\r\n\r\n接下来，我们来看看 XMake 中集成使用 Vcpkg 提供的包：\r\n\r\n```lua\r\nadd_requires(\"vcpkg::zlib\", {alias = \"zlib\"})\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    add_packages(\"zlib\")\r\n```\r\n\r\n我们只需要通过 `add_requires` 配置上对应的包名，以及 `vcpkg::` 包命名空间，就能直接集成使用 vcpkg 提供的 zlib 包。\r\n\r\n然后，我们只需要执行 xmake 命令，既可完成整个编译过程，包括 zlib 包的自动安装，无需额外手动执行 `vcpkg install zlib`。\r\n\r\n```bash\r\n$ xmake\r\nnote: try installing these packages (pass -y to skip confirm)?\r\n-> vcpkg::zlib\r\nplease input: y (y/n)\r\n\r\n=> install vcpkg::zlib .. ok\r\n[ 25%]: compiling.release src\\main.cpp\r\n[ 50%]: linking.release test\r\n[100%]: build ok!\r\n```\r\n\r\n#### XMake 和 Conan\r\n\r\n接下来是集成 Conan 的包，完全一样的方式，仅仅执行换个包管理器名字。\r\n\r\n```lua\r\nadd_requires(\"conan::zlib\", {alias = \"zlib\"})\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    add_packages(\"zlib\")\r\n```\r\n\r\nXMake 同样会自动安装 conan 中的 zlib 包，然后自动集成编译。\r\n\r\n#### XMake 自建包管理\r\n\r\nXMake 跟 CMake 还有其他构建系统，最大的不同点，也就是最大的优势之一，就是它有完全自建的包管理系统，我们完全可以不依赖 vcpkg/conan，也可以快速集成依赖包，比如：\r\n\r\n```lua\r\nadd_requires(\"zlib 1.2.x\", \"tbox >= 1.6.0\")\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    add_packages(\"zlib\", \"tbox\")\r\n```\r\n\r\n而且，它还支持完整的语义版本选择，多平台的包集成，交叉编译工具链的包集成，甚至编译工具链包的自动拉取使用。\r\n\r\n不仅如此，我们开可以对定制化配置对自建包的依赖，例如：\r\n\r\n##### 使用调式版本依赖包\r\n\r\n我们可以使用 debug 版本库，实现对依赖库的断点调试。\r\n\r\n```lua\r\nadd_requires(\"zlib\", {debug = true})\r\n```\r\n\r\n##### 设置 msvc 运行时库\r\n\r\n```lua\r\nadd_requires(\"zlib\", {configs = {vs_runtime = \"MD\"}})\r\n```\r\n\r\n##### 使用动态库\r\n\r\n默认集成的是静态库，我们也可以切换到动态库。\r\n\r\n```lua\r\nadd_requires(\"zlib\", {configs = {shared = true}})\r\n```\r\n\r\n##### 语义版本支持\r\n\r\nXMake 的自建包集成支持完整的版本语义规范。\r\n\r\n```lua\r\nadd_requires(\"zlib 1.2.x\")\r\nadd_requires(\"zlib >=1.2.10\")\r\nadd_requires(\"zlib ~1.2.0\")\r\n```\r\n\r\n##### 禁止使用系统库\r\n\r\n默认情况下，如果版本匹配，XMake 会优先查找使用系统上用户已经安装的库，当然我们也可以强制禁止查找使用系统库，仅仅从自建包仓库中下载安装包。\r\n\r\n```lua\r\nadd_requires(\"zlib\", {system = true})\r\n```\r\n\r\n##### 可选依赖包\r\n\r\n如果依赖包集成失败，XMake 会自动报错，中断编译，提示用户：`zlib not found`，但是我们也可以设置为可选包集成，这样的话，即使库最终没安装成功，也不影响项目的编译，仅仅只是跳过这个依赖。\r\n\r\n```lua\r\nadd_requires(\"zlib\", {optional = true})\r\n```\r\n\r\n##### 包的定制化配置\r\n\r\n比如，集成使用开启了 context/coroutine 模块配置的 boost 库。\r\n\r\n```lua\r\nadd_requires(\"boost\", {configs = {context = true, coroutine = true}})\r\n```\r\n\r\n#### 支持的包管理仓库\r\n\r\nXMake 除了支持 vcpkg/conan 还有自建仓库的包集成支持，还支持其他的包管理仓库，例如：Conda/Homebrew/Apt/Pacman/Clib/Dub 等等，而且集成方式完全一致。\r\n\r\n用户可与快速切换使用其他的仓库包，而不需要花太多时间去研究如何集成它们。\r\n\r\n因此，XMake 并没有破坏 C/C++ 生态，而是极大的复用现有 C/C++ 生态的基础上，努力改进用户对 C/C++ 依赖包的使用体验，提高开发效率，让用户能够拥有更多的时间去关注项目本身。\r\n\r\n* 官方自建仓库 [xmake-repo]( https://github.com/xmake-io/xmake-repo) (tbox >1.6.1)\r\n* 官方包管理器 [Xrepo]( https://github.com/xmake-io/xrepo)\r\n* [用户自建仓库]( https://xmake.io/#/zh-cn/package/remote_package?id=%e4%bd%bf%e7%94%a8%e8%87%aa%e5%bb%ba%e7%a7%81%e6%9c%89%e5%8c%85%e4%bb%93%e5%ba%93)\r\n* Conan (conan::openssl/1.1.1g)\r\n* Conda (conda::libpng 1.3.67)\r\n* Vcpkg (vcpkg:ffmpeg)\r\n* Homebrew/Linuxbrew (brew::pcre2/libpcre2-8)\r\n* Pacman on archlinux/msys2 (pacman::libcurl)\r\n* Apt on ubuntu/debian (apt::zlib1g-dev)\r\n* Clib (clib::clibs/bytes@0.0.4)\r\n* Dub (dub::log 0.4.3)\r\n\r\n#### 独立的包管理命令（ Xrepo ）\r\n\r\n为了方便 XMake 的自建仓库中的包管理，以及第三方包的管理使用，我们也提供了独立的 Xrepo cli 命令工具，来方便的管理我们的依赖包\r\n\r\n我们可以使用这个工具，快速方便的完成下面的管理操作：\r\n\r\n- 安装包：`xrepo install zlib`\r\n- 卸载包：`xrepo remove zlib`\r\n- 获取包信息：`xrepo info zlib`\r\n- 获取包编译链接 flags：`xrepo fetch zlib`\r\n- 加载包虚拟 Shell 环境：`xrepo env shell` （这是一个很强大的特性）\r\n\r\n我们可以到 [Xrepo 项目主页]( https://github.com/xmake-io/xrepo) 查看更多的介绍和使用方式。\r\n\r\n![]( https://xrepo.xmake.io/assets/img/xrepo.gif)\r\n\r\n\r\n### 轻量无依赖\r\n\r\n使用 Meson/Scons 需要先安装 python/pip，使用 Bazel 需要先安装 java 等运行时环境，而 XMake 不需要额外安装任何依赖库和环境，自身安装包仅仅 2-3M，非常的轻量。\r\n\r\n尽管 XMake 是基于 lua，但是借助于 lua 胶水语言的轻量级特性，xmake 已将其完全内置，因此安装完 XMake 等同于拥有了一个完整的 lua vm 。\r\n\r\n有人会说，编译工具链总还是需要的吧，也不完全是，Windows 上，我们提供了预编译安装包，可以直接下载安装编译，地址见：[Releases]( https://github.com/xmake-io/xmake/releases)\r\n\r\n另外，XMake 还支持远程拉取编译工具链，因此即使你的系统环境，还没有安装任何编译器，也没关系，用户完全不用考虑如何折腾编译环境，只需要在 xmake.lua 里面配置上需要的工具链即可。\r\n\r\n比如，我们在 Windows 上使用 mingw-w64 工具链来编译 C/C++ 工程，只需要做如下配置即可。\r\n\r\n```lua\r\nadd_requires(\"mingw-w64\")\r\ntarget(\"test\")\r\n    set_kind(\"binary\")\r\n    add_files(\"src/*.c\")\r\n    set_toolchains(\"mingw@mingw-w64\")\r\n```\r\n\r\n通过 `set_toolchains` 配置绑定 mingw-w64 工具链包后，XMake 就会自动检测当前系统是否存在 mingw-64，如果还没安装，它会自动下载安装，然后完成项目编译，整个过程，用户仅仅只需要执行 `xmake` 这个命令就能完成。\r\n\r\n```bash\r\n$ xmake\r\nnote: try installing these packages (pass -y to skip confirm)?\r\nin xmake-repo:\r\n-> mingw-w64 8.1.0 [vs_runtime:MT]\r\nplease input: y (y/n)\r\n\r\n=> download https://jaist.dl.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z .. ok\r\nchecking for mingw directory ... C:\\Users\\ruki\\AppData\\Local\\.xmake\\packages\\m\\mingw-w64\\8.1.0\\aad6257977e0449595004d7441358fc5\r\n[ 25%]: compiling.release src\\main.cpp\r\n[ 50%]: linking.release test.exe\r\n[100%]: build ok!\r\n```\r\n\r\n除了 mingw-w64，我们还可以配置远程拉取使用其他的工具链，甚至交叉编译工具链，例如：llvm-mingw, llvm, tinycc, muslcc, gnu-rm, zig 等等。\r\n\r\n如果大家还想进一步了解远程工具链的拉取集成，可以看下文档：[自动拉取远程工具链]( https://xmake.io/#/zh-cn/package/remote_package?id=%e8%87%aa%e5%8a%a8%e6%8b%89%e5%8f%96%e8%bf%9c%e7%a8%8b%e5%b7%a5%e5%85%b7%e9%93%be)。\r\n\r\n### 极速并行编译\r\n\r\n大家都知道 Ninja 构建非常快，因此很多人都喜欢用 CMake/Meson 生成 build.ninja  后，使用 Ninja 来满足极速构建的需求。\r\n\r\n尽管 Ninja 很快，但是我们还是需要先通过 meson.build 和 CMakelist.txt 文件生成 build.ninja 才行，这个生成过程也会占用几秒甚至十几秒的时间。\r\n\r\n而 XMake 不仅仅拥有和 Ninja 近乎相同的构建速度，而且不需要额外再生成其他构建文件，直接内置构建系统，任何情况下，只需要一个 `xmake` 命令就可以实现极速编译。\r\n\r\n我们也做过一些对比测试数据，供大家参考：\r\n\r\n#### 多任务并行编译测试\r\n\r\n| 构建系统        | Termux (8core/-j12) | 构建系统         | MacOS (8core/-j12) |\r\n|-----            | ----                | ---              | ---                |\r\n|xmake            | 24.890s             | xmake            | 12.264s            |\r\n|ninja            | 25.682s             | ninja            | 11.327s            |\r\n|cmake(gen+make)  | 5.416s+28.473s      | cmake(gen+make)  | 1.203s+14.030s     |\r\n|cmake(gen+ninja) | 4.458s+24.842s      | cmake(gen+ninja) | 0.988s+11.644s     |\r\n\r\n#### 单任务编译测试\r\n\r\n| 构建系统        | Termux (-j1)     | 构建系统         | MacOS (-j1)    |\r\n|-----            | ----             | ---              | ---            |\r\n|xmake            | 1m57.707s        | xmake            | 39.937s        |\r\n|ninja            | 1m52.845s        | ninja            | 38.995s        |\r\n|cmake(gen+make)  | 5.416s+2m10.539s | cmake(gen+make)  | 1.203s+41.737s |\r\n|cmake(gen+ninja) | 4.458s+1m54.868s | cmake(gen+ninja) | 0.988s+38.022s |\r\n\r\n\r\n### 傻瓜式多平台编译\r\n\r\nXMake 的另外一个特点，就是高效简单的多平台编译，不管你是编译 windows/linux/macOS 下的程序，还是编译 iphoneos/android 又或者是交叉编译。\r\n\r\n编译的配置方式大同小异，不必让用户去这折腾研究各个平台下如何去编译。\r\n\r\n![]( https://xmake.io/assets/img/index/xmake-basic-render.gif)\r\n\r\n#### 编译本机 Windows/Linux/MacOS  程序\r\n\r\n当前本机程序编译，我们仅仅只需要执行：\r\n\r\n```bash\r\n$ xmake\r\n```\r\n\r\n对比 CMake\r\n\r\n```bash\r\n$ mkdir build\r\n$ cd build\r\n$ cmake --build ..\r\n```\r\n\r\n#### 编译 Android 程序\r\n\r\n```bash\r\n$ xmake f -p android --ndk=~/android-ndk-r21e\r\n$ xmake\r\n```\r\n\r\n对比 CMake\r\n\r\n```bash\r\n$ mkdir build\r\n$ cd build\r\n$ cmake -DCMAKE_TOOLCHAIN_FILE=~/android-ndk-r21e/build/cmake/android.toolchain.cmake ..\r\n$ make\r\n```\r\n\r\n#### 编译 iOS 程序\r\n\r\n```bash\r\n$ xmake f -p iphoneos\r\n$ xmake\r\n```\r\n\r\n对比 CMake\r\n\r\n```bash\r\n$ mkdir build\r\n$ cd build\r\n$ wget https://raw.githubusercontent.com/leetal/ios-cmake/master/ios.toolchain.cmake\r\n$ cmake -DCMAKE_TOOLCHAIN_FILE=`pwd`/ios.toolchain.cmake ..\r\n$ make\r\n```\r\n\r\n我没有找到很方便的方式去配置编译 ios 程序，仅仅只能从其他地方找到一个第三方的 ios 工具链去配置编译。\r\n\r\n#### 交叉编译\r\n\r\n我们通常只需要设置交叉编译工具链根目录，XMake 会自动检测工具链结构，提取里面的编译器参与编译，不需要额外配置什么。\r\n\r\n```bash\r\n$ xmake f -p cross --sdk=~/aarch64-linux-musl-cross\r\n$ xmake\r\n```\r\n\r\n对比 CMake\r\n\r\n我们需要先额外写一个 cross-toolchain.cmake 的交叉工具链配置文件。\r\n\r\n```cmake\r\nset(CMAKE_SYSTEM_NAME Linux)\r\nset(CMAKE_SYSTEM_PROCESSOR aarch64)\r\n\r\nset(TOOL_CHAIN_DIR ~/aarch64-linux-musl)\r\nset(TOOL_CHAIN_INCLUDE ${TOOL_CHAIN_DIR}/aarch64-linux-musl/include)\r\nset(TOOL_CHAIN_LIB ${TOOL_CHAIN_DIR}/aarch64-linux-musl/lib)\r\n\r\nset(CMAKE_C_COMPILER \"aarch64-linux-gcc\")\r\nset(CMAKE_CXX_COMPILER \"aarch64-linux-g++\")\r\n\r\nset(CMAKE_FIND_ROOT_PATH ${TOOL_CHAIN_DIR}/aarch64-linux-musl)\r\n\r\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\r\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\r\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\r\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\r\n\r\ninclude_directories(${TOOL_CHAIN_DIR}/aarch64-linux-musl/include)\r\nset(CMAKE_INCLUDE_PATH ${TOOL_CHAIN_INCLUDE})\r\nset(CMAKE_LIBRARY_PATH ${TOOL_CHAIN_LIB})\r\n```\r\n\r\n```bash\r\n$ mkdir build\r\n$ cd build\r\n$ cmake -DCMAKE_TOOLCHAIN_FILE=../cross-toolchain.cmake ..\r\n$ make\r\n```\r\n\r\n### 结语\r\n\r\n如果你是 C/C++ 开发的新手，可以通过 XMake 快速上手入门 C/C++ 编译构建。\r\n\r\n如果你想开发维护跨平台 C/C++ 项目，也可以考虑使用 XMake 来维护构建，提高开发效率，让你更加专注于项目本身，不再为折腾移植依赖库而烦恼。\r\n\r\n欢迎关注 XMake 项目：\r\n\r\n- [Github 项目地址]( https://github.com/xmake-io/xmake/)\r\n- [项目主页]( https://xmake.io/#/)\r\n- [XMake 包管理仓库]( https://github.com/xmake-io/xmake-repo)\r\n- 社区\r\n  - [Telegram 群组]( https://t.me/tbooxorg)\r\n  - [Discord 聊天室]( https://discord.gg/xmake)\r\n  - QQ 群：343118190, 662147501\r\n  - 微信公众号：tboox-os\r\n - 课程：[Xmake 带你轻松构建 C/C++ 项目]( https://xmake.io/#/zh-cn/about/course)\r\n - 活动：[开源之夏 & Xmake]( https://tboox.org/cn/2021/04/29/xmake-summer-ospp/)", "content_rendered": "<h3>XMake 是什么</h3>\n<p><a href=\"https://github.com/xmake-io/xmake\" rel=\"nofollow\">XMake</a> 是一个基于 Lua 的 现代化 C/C++ 构建系统。</p>\n<p>它的语法简洁易上手，对新手友好，即使完全不会 lua 也能够快速入门，并且完全无任何依赖，轻量，跨平台。</p>\n<p>同时，它也是一个自满足的构建系统，拥有强大的包管理系统，快速的构建引擎。</p>\n<p>相比 Ninja/Scons/Make 作为 Build backend，CMake/Meson 作为 Project Generator，那么 XMake 就是这两者外加一个包管理。</p>\n<pre><code>xmake = Build backend + Project Generator + Package Manager\n</code></pre>\n<p>因此，只需要安装一个不到 3M 的 XMake 安装包，你就可以不用再安装其他各种工具，甚至连 make 都不需要安装，也不需要安装 Python 、Java 等重量级的运行时环境，就可以开始您的 C/C++ 开发之旅。</p>\n<p>也许，有人会说，编译器总需要安装的吧。这也不是必须的，因为 XMake 的包管理也支持自动远程拉取需要的各种编译工具链，比如：llvm, Mingw, Android NDK 或者交叉编译工具链。</p>\n<h3>为什么要做 XMake</h3>\n<p>每当在 Reddit 社区跟别人讨论起 XMake，大家总是会拿下面这张图来吐槽。</p>\n<p><img alt=\"\" class=\"embedded_image\" loading=\"lazy\" referrerpolicy=\"no-referrer\" rel=\"noreferrer\" src=\"https://imgs.xkcd.com/comics/standards.png\"/></p>\n<p>尽管有些无奈，也被吐槽的有些麻木了，不过我还是想说明下，做 XMake 的初衷，并不是为了分裂 C/C++  生态，相反，XMake 尽可能地复用了现有生态。</p>\n<p>同时也让用户在开发 C/C++ 项目的时候，拥有与其他语言一样的良好体验，比如：Rust/Cargo，Nodejs/Npm, Dlang/Dub，不再为到处找第三包，研究如何移植编译而折腾。</p>\n<p>因此，如果您还不了解 XMake，请不要过早下定论，可以先尝试使用下，或者花点时间看完下文的详细介绍。</p>\n<h3>XMake 的特性和优势</h3>\n<p>经常有人问我 XMake 有什么特别之处，相比现有 CMake 、Meson 此类构建工具有什么优势，我为什么要使用 XMake 而不是 CMake ？</p>\n<p>先说特点和优势，XMake 有以下几点：</p>\n<ul>\n<li>简洁易学的配置语法，非 DSL</li>\n<li>强大的包管理，支持语义版本，工具链管理</li>\n<li>足够轻量，无依赖</li>\n<li>极速编译，构建速度和 Ninja 一样快</li>\n<li>简单方便的多平台、工具链切换</li>\n<li>完善的插件系统</li>\n<li>灵活的构建规则</li>\n</ul>\n<p>至于 CMake，毕竟已成事实上的标准，生态完善，功能强大。</p>\n<p>我从没想过让 XMake 去替代它，也替代不了，完全不是一个量级的，但是 CMake 也有许多为人所诟病的短板，比如：语法复杂难懂，包管理支持不完善等等。</p>\n<p>因此使用 XMake 可以作为一种补充，对于那些想要简单快速入门 C/C++ 开发的新手，或者想要更加方便易用的包管理，或者想临时快速写一些短小的测试项目。</p>\n<p>XMake 都可以帮他们提升开发效率，让其更加关注 C/C++ 项目本身，而不是花更多的时间在构建工具和开发环境上。</p>\n<p>下面，我来具体介绍 XMake 的这些主要特性。</p>\n<h3>语法简洁易上手</h3>\n<p>CMake 自己设计一门 DSL 语言用来做项目配置，这对用户来讲提高了学习成本，而且它的语法可读性不是很直观，很容易写出过于复杂的配置脚本，也提高了维护成本。</p>\n<p>而 XMake 复用现有知名的 Lua 语言作为基础，并且其上提供了更加简单直接的配置语法。</p>\n<p>Lua 本身就是一门简单轻量的胶水语言，关键字和内置类型就那么几种，看个一篇文章，就能基本入门了，并且相比 DSL，能够从网上更方便的获取到大量相关资料和教程。</p>\n<h4>基础语法</h4>\n<p>不过，还是有人会吐槽：那不是还得学习 Lua 么？</p>\n<p>其实也不用，XMake 采用了 <code>描述域</code> 和 <code>脚本域</code> 分离的方式，使得初学者用户在 80% 的情况下，只需要在描述域以更简单直接的方式来配置，完全可以不把它当成 Lua 脚本，例如：</p>\n<pre><code class=\"language-lua\">target(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    add_files(\"test/*.c\", \"example/**.cpp\")\n</code></pre>\n<p>如果因为，看着有括号，还是像脚本语言的函数调用，那我们也可以这么写（是否带括号看个人喜好，不过我个人还是建议使用上面的方式）</p>\n<pre><code class=\"language-lua\">target \"test\"\n    set_kind \"binary\"\n    add_files \"src/*.c\"\n    add_files \"test/*.c\"\n    add_files \"example/**.cpp\"\n</code></pre>\n<p>我们只需要知道常用配置接口，即使不完全不会 Lua 也能快速配置了。</p>\n<p>我们可以对比下 CMake 的配置：</p>\n<pre><code class=\"language-cmake\">add_executable(test \"\")\nfile(GLOB SRC_FILES \"src/*.c\")\nfile(GLOB TEST_FILES \"test/*.c\")\nfile(GLOB_RECURSE EXAMPLE_FILES \"example/*.cpp\")\ntarget_sources(test PRIVATE\n    ${SRC_FILES}\n    ${TEST_FILES}\n    ${EXAMPLE_FILES}\n)\n</code></pre>\n<p>哪个更直观可读，一目了然。</p>\n<h4>条件配置</h4>\n<p>如果，你已经初步了解了一些 Lua 等基础知识，比如 <code>if then</code> 等条件判断，那么可以进一步做一些条件配置。</p>\n<pre><code class=\"language-lua\">target(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/main.c\")\n    if is_plat(\"macosx\", \"linux\") then\n        add_defines(\"TEST1\", \"TEST2\")\n    end\n    if is_plat(\"windows\") and is_mode(\"release\") then\n        add_cxflags(\"-Ox\", \"-fp:fast\")\n    end\n</code></pre>\n<p>继续对比下 CMake 版本配置：</p>\n<pre><code class=\"language-cmake\">add_executable(test \"\")\nif (APPLE OR LINUX)\n    target_compile_definitions(test PRIVATE TEST1 TEST2)\nendif()\nif (WIN32)\n    target_compile_options(test PRIVATE $&lt;$&lt;CONFIG:Release&gt;:-Ox -fp:fast&gt;)\nendif()\ntarget_sources(test PRIVATE\n    src/main.c\n)\n</code></pre>\n<h4>复杂脚本</h4>\n<p>如果你已经晋升为 XMake 的高端玩家，Lua 语法了然于胸，想要更加灵活的定制化配置需要，并且描述域的几行简单配置已经满足不了你的需求。</p>\n<p>那么 XMake 也提供了更加完整的 Lua 脚本定制化能力，你可以写任何复杂的脚本。</p>\n<p>比如在构建之前，对所有源文件进行一些预处理，在构建之后，执行外部 gradle 命令进行后期打包，甚至我们还可以重写内部链接规则，实现深度定制编译，我们可以通过<a href=\"https://xmake.io/#/zh/manual?id=import\" rel=\"nofollow\">import</a> 接口，导入内置的 linker 扩展模块，实现复杂灵活的链接过程。</p>\n<pre><code class=\"language-lua\">target(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    before_build_file(function (target, sourcefile)\n        io.replace(sourcefile, \"#define HAVE_XXX 1\", \"#define HAVE_XXX 0\")\n    end)\n    on_link(function (target)\n        import(\"core.tool.linker\")\n        linker.link(\"binary\", \"cc\", target:objectfiles(), target:targetfile(), {target = target})\n    end)\n    after_build(function (target)\n        if is_plat(\"android\" then\n            os.cd(\"android/app\")\n            os.exec(\"./gradlew app:assembleDebug\")\n        end\n    end)\n</code></pre>\n<p>如果换成 CMake，也可以 add_custom_command 里面实现，不过里面似乎只能简单的执行一些批处理命令，没法做各种复杂的逻辑判断，模块加载，自定义配置脚本等等。</p>\n<p>当然，使用 cmake 肯定也能实现上面描述的功能，但绝对不会那么简单。</p>\n<p>如果有熟悉 cmake 的人，也可以尝试帮忙完成下面的配置：</p>\n<pre><code class=\"language-cmake\">add_executable(test \"\")\nfile(GLOB SRC_FILES \"src/*.c\")\nadd_custom_command(TARGET test PRE_BUILD\n    -- TODO\n    COMMAND echo hello\n)\nadd_custom_command(TARGET test POST_BUILD\n    COMMAND cd android/app\n    COMMAND ./gradlew app:assembleDebug\n)\n-- How can we override link stage?\ntarget_sources(test PRIVATE\n    ${SRC_FILES}\n)\n</code></pre>\n<h3>强大的包管理</h3>\n<p>众所周知，做 C/C++ 相关项目开发，最头大的就是各种依赖包的集成，由于没有像 Rust/Cargo 那样完善的包管理系统。</p>\n<p>因此，我们每次想使用一个第三方库，都需要各种找，研究各种平台的移植编译，还经常遇到各种编译问题，极大耽误了开发者时间，无法集中精力去投入到实际的项目开发中去。</p>\n<p>好不容易当前平台搞定了，换到其他平台，有需要重新折腾一遍依赖包，为了解决这个问题，出现了一些第三方的包管理器，比如 vcpkg/conan/conda 等等，但有些不支持语义版本，有些支持的平台有限，但不管怎样，总算是为解决 C/C++ 库的依赖管理迈进了很大一步。</p>\n<p>但是，光有包管理器，C/C++ 项目中使用它们还是比较麻烦，因为还需要对应构建工具能够很好的对其进行集成支持才行。</p>\n<h4>CMake 和 Vcpkg</h4>\n<p>我们先来看下 CMake 和 Vcpkg 的集成支持：</p>\n<pre><code>cmake_minimum_required(VERSION 3.0)\nproject(test)\nfind_package(unofficial-sqlite3 CONFIG REQUIRED)\nadd_executable(main main.cpp)\ntarget_link_libraries(main PRIVATE unofficial::sqlite3::sqlite3)\n</code></pre>\n<p>缺点：</p>\n<ul>\n<li>还需要额外配置 <code>-DCMAKE_TOOLCHAIN_FILE=&lt;vcpkg_dir&gt;/scripts/buildsystems/vcpkg.cmake\"</code></li>\n<li>不支持自动安装依赖包，还需要用户手动执行 <code>vcpkg install xxx</code> 命令安装</li>\n<li>vcpkg 的语义版本选择不支持 （据说新版本开始支持了）</li>\n</ul>\n<h4>CMake 和 Conan</h4>\n<pre><code>```cmake\ncmake_minimum_required(VERSION 2.8.12)\nproject(Hello)\n\nadd_definitions(\"-std=c++11\")\n\ninclude(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)\nconan_basic_setup()\n\nadd_executable(hello hello.cpp)\ntarget_link_libraries(hello gtest)\n</code></pre>\n<p>conanfile.txt</p>\n<pre><code class=\"language-text\">[requires]\ngtest/1.10.0\n\n[generators]\ncmake\n</code></pre>\n<p>缺点：</p>\n<ul>\n<li>同样，还是需要额外调用 <code>conan install ..</code> 来安装包</li>\n<li>还需要额外配置一个 conanfile.txt 文件去描述包依赖规则</li>\n</ul>\n<h4>Meson 和 Vcpkg</h4>\n<p>我没找到如何在 Meson 中去使用 vcpkg 包，仅仅找到一篇相关的 <a href=\"https://github.com/mesonbuild/meson/issues/3500\" rel=\"nofollow\">Issue #3500</a> 讨论。</p>\n<h4>Meson 和 Conan</h4>\n<p>Meson 似乎还没有对 Conan 进行支持，但是 Conan 官方文档上有解决方案，对齐进行支持，但是很复杂，我是没看会，大家可以自行研究：<a href=\"https://docs.conan.io/en/latest/reference/build_helpers/meson.html\" rel=\"nofollow\">https://docs.conan.io/en/latest/reference/build_helpers/meson.html</a></p>\n<h4>XMake 和 Vcpkg</h4>\n<p>前面讲了这么多，其他构建工具和包管理的集成，个人感觉用起来很麻烦，而且不同的包管理器，集成方式差别很大，用户想要快速从 Vcpkg 切换到 Conan 包，改动量非常大。</p>\n<p>接下来，我们来看看 XMake 中集成使用 Vcpkg 提供的包：</p>\n<pre><code class=\"language-lua\">add_requires(\"vcpkg::zlib\", {alias = \"zlib\"})\ntarget(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    add_packages(\"zlib\")\n</code></pre>\n<p>我们只需要通过 <code>add_requires</code> 配置上对应的包名，以及 <code>vcpkg::</code> 包命名空间，就能直接集成使用 vcpkg 提供的 zlib 包。</p>\n<p>然后，我们只需要执行 xmake 命令，既可完成整个编译过程，包括 zlib 包的自动安装，无需额外手动执行 <code>vcpkg install zlib</code>。</p>\n<pre><code class=\"language-bash\">$ xmake\nnote: try installing these packages (pass -y to skip confirm)?\n-&gt; vcpkg::zlib\nplease input: y (y/n)\n\n=&gt; install vcpkg::zlib .. ok\n[ 25%]: compiling.release src\\main.cpp\n[ 50%]: linking.release test\n[100%]: build ok!\n</code></pre>\n<h4>XMake 和 Conan</h4>\n<p>接下来是集成 Conan 的包，完全一样的方式，仅仅执行换个包管理器名字。</p>\n<pre><code class=\"language-lua\">add_requires(\"conan::zlib\", {alias = \"zlib\"})\ntarget(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    add_packages(\"zlib\")\n</code></pre>\n<p>XMake 同样会自动安装 conan 中的 zlib 包，然后自动集成编译。</p>\n<h4>XMake 自建包管理</h4>\n<p>XMake 跟 CMake 还有其他构建系统，最大的不同点，也就是最大的优势之一，就是它有完全自建的包管理系统，我们完全可以不依赖 vcpkg/conan，也可以快速集成依赖包，比如：</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib 1.2.x\", \"tbox &gt;= 1.6.0\")\ntarget(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    add_packages(\"zlib\", \"tbox\")\n</code></pre>\n<p>而且，它还支持完整的语义版本选择，多平台的包集成，交叉编译工具链的包集成，甚至编译工具链包的自动拉取使用。</p>\n<p>不仅如此，我们开可以对定制化配置对自建包的依赖，例如：</p>\n<h5>使用调式版本依赖包</h5>\n<p>我们可以使用 debug 版本库，实现对依赖库的断点调试。</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib\", {debug = true})\n</code></pre>\n<h5>设置 msvc 运行时库</h5>\n<pre><code class=\"language-lua\">add_requires(\"zlib\", {configs = {vs_runtime = \"MD\"}})\n</code></pre>\n<h5>使用动态库</h5>\n<p>默认集成的是静态库，我们也可以切换到动态库。</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib\", {configs = {shared = true}})\n</code></pre>\n<h5>语义版本支持</h5>\n<p>XMake 的自建包集成支持完整的版本语义规范。</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib 1.2.x\")\nadd_requires(\"zlib &gt;=1.2.10\")\nadd_requires(\"zlib ~1.2.0\")\n</code></pre>\n<h5>禁止使用系统库</h5>\n<p>默认情况下，如果版本匹配，XMake 会优先查找使用系统上用户已经安装的库，当然我们也可以强制禁止查找使用系统库，仅仅从自建包仓库中下载安装包。</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib\", {system = true})\n</code></pre>\n<h5>可选依赖包</h5>\n<p>如果依赖包集成失败，XMake 会自动报错，中断编译，提示用户：<code>zlib not found</code>，但是我们也可以设置为可选包集成，这样的话，即使库最终没安装成功，也不影响项目的编译，仅仅只是跳过这个依赖。</p>\n<pre><code class=\"language-lua\">add_requires(\"zlib\", {optional = true})\n</code></pre>\n<h5>包的定制化配置</h5>\n<p>比如，集成使用开启了 context/coroutine 模块配置的 boost 库。</p>\n<pre><code class=\"language-lua\">add_requires(\"boost\", {configs = {context = true, coroutine = true}})\n</code></pre>\n<h4>支持的包管理仓库</h4>\n<p>XMake 除了支持 vcpkg/conan 还有自建仓库的包集成支持，还支持其他的包管理仓库，例如：Conda/Homebrew/Apt/Pacman/Clib/Dub 等等，而且集成方式完全一致。</p>\n<p>用户可与快速切换使用其他的仓库包，而不需要花太多时间去研究如何集成它们。</p>\n<p>因此，XMake 并没有破坏 C/C++ 生态，而是极大的复用现有 C/C++ 生态的基础上，努力改进用户对 C/C++ 依赖包的使用体验，提高开发效率，让用户能够拥有更多的时间去关注项目本身。</p>\n<ul>\n<li>官方自建仓库 <a href=\"https://github.com/xmake-io/xmake-repo\" rel=\"nofollow\">xmake-repo</a> (tbox &gt;1.6.1)</li>\n<li>官方包管理器 <a href=\"https://github.com/xmake-io/xrepo\" rel=\"nofollow\">Xrepo</a></li>\n<li><a href=\"https://xmake.io/#/zh-cn/package/remote_package?id=%e4%bd%bf%e7%94%a8%e8%87%aa%e5%bb%ba%e7%a7%81%e6%9c%89%e5%8c%85%e4%bb%93%e5%ba%93\" rel=\"nofollow\">用户自建仓库</a></li>\n<li>Conan (conan::openssl/1.1.1g)</li>\n<li>Conda (conda::libpng 1.3.67)</li>\n<li>Vcpkg (vcpkg:ffmpeg)</li>\n<li>Homebrew/Linuxbrew (brew::pcre2/libpcre2-8)</li>\n<li>Pacman on archlinux/msys2 (pacman::libcurl)</li>\n<li>Apt on ubuntu/debian (apt::zlib1g-dev)</li>\n<li>Clib (clib::clibs/bytes@0.0.4)</li>\n<li>Dub (dub::log 0.4.3)</li>\n</ul>\n<h4>独立的包管理命令（ Xrepo ）</h4>\n<p>为了方便 XMake 的自建仓库中的包管理，以及第三方包的管理使用，我们也提供了独立的 Xrepo cli 命令工具，来方便的管理我们的依赖包</p>\n<p>我们可以使用这个工具，快速方便的完成下面的管理操作：</p>\n<ul>\n<li>安装包：<code>xrepo install zlib</code></li>\n<li>卸载包：<code>xrepo remove zlib</code></li>\n<li>获取包信息：<code>xrepo info zlib</code></li>\n<li>获取包编译链接 flags：<code>xrepo fetch zlib</code></li>\n<li>加载包虚拟 Shell 环境：<code>xrepo env shell</code> （这是一个很强大的特性）</li>\n</ul>\n<p>我们可以到 <a href=\"https://github.com/xmake-io/xrepo\" rel=\"nofollow\">Xrepo 项目主页</a> 查看更多的介绍和使用方式。</p>\n<p><img alt=\"\" class=\"embedded_image\" loading=\"lazy\" referrerpolicy=\"no-referrer\" rel=\"noreferrer\" src=\"https://xrepo.xmake.io/assets/img/xrepo.gif\"/></p>\n<h3>轻量无依赖</h3>\n<p>使用 Meson/Scons 需要先安装 python/pip，使用 Bazel 需要先安装 java 等运行时环境，而 XMake 不需要额外安装任何依赖库和环境，自身安装包仅仅 2-3M，非常的轻量。</p>\n<p>尽管 XMake 是基于 lua，但是借助于 lua 胶水语言的轻量级特性，xmake 已将其完全内置，因此安装完 XMake 等同于拥有了一个完整的 lua vm 。</p>\n<p>有人会说，编译工具链总还是需要的吧，也不完全是，Windows 上，我们提供了预编译安装包，可以直接下载安装编译，地址见：<a href=\"https://github.com/xmake-io/xmake/releases\" rel=\"nofollow\">Releases</a></p>\n<p>另外，XMake 还支持远程拉取编译工具链，因此即使你的系统环境，还没有安装任何编译器，也没关系，用户完全不用考虑如何折腾编译环境，只需要在 xmake.lua 里面配置上需要的工具链即可。</p>\n<p>比如，我们在 Windows 上使用 mingw-w64 工具链来编译 C/C++ 工程，只需要做如下配置即可。</p>\n<pre><code class=\"language-lua\">add_requires(\"mingw-w64\")\ntarget(\"test\")\n    set_kind(\"binary\")\n    add_files(\"src/*.c\")\n    set_toolchains(\"mingw@mingw-w64\")\n</code></pre>\n<p>通过 <code>set_toolchains</code> 配置绑定 mingw-w64 工具链包后，XMake 就会自动检测当前系统是否存在 mingw-64，如果还没安装，它会自动下载安装，然后完成项目编译，整个过程，用户仅仅只需要执行 <code>xmake</code> 这个命令就能完成。</p>\n<pre><code class=\"language-bash\">$ xmake\nnote: try installing these packages (pass -y to skip confirm)?\nin xmake-repo:\n-&gt; mingw-w64 8.1.0 [vs_runtime:MT]\nplease input: y (y/n)\n\n=&gt; download https://jaist.dl.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z .. ok\nchecking for mingw directory ... C:\\Users\\ruki\\AppData\\Local\\.xmake\\packages\\m\\mingw-w64\\8.1.0\\aad6257977e0449595004d7441358fc5\n[ 25%]: compiling.release src\\main.cpp\n[ 50%]: linking.release test.exe\n[100%]: build ok!\n</code></pre>\n<p>除了 mingw-w64，我们还可以配置远程拉取使用其他的工具链，甚至交叉编译工具链，例如：llvm-mingw, llvm, tinycc, muslcc, gnu-rm, zig 等等。</p>\n<p>如果大家还想进一步了解远程工具链的拉取集成，可以看下文档：<a href=\"https://xmake.io/#/zh-cn/package/remote_package?id=%e8%87%aa%e5%8a%a8%e6%8b%89%e5%8f%96%e8%bf%9c%e7%a8%8b%e5%b7%a5%e5%85%b7%e9%93%be\" rel=\"nofollow\">自动拉取远程工具链</a>。</p>\n<h3>极速并行编译</h3>\n<p>大家都知道 Ninja 构建非常快，因此很多人都喜欢用 CMake/Meson 生成 build.ninja  后，使用 Ninja 来满足极速构建的需求。</p>\n<p>尽管 Ninja 很快，但是我们还是需要先通过 meson.build 和 CMakelist.txt 文件生成 build.ninja 才行，这个生成过程也会占用几秒甚至十几秒的时间。</p>\n<p>而 XMake 不仅仅拥有和 Ninja 近乎相同的构建速度，而且不需要额外再生成其他构建文件，直接内置构建系统，任何情况下，只需要一个 <code>xmake</code> 命令就可以实现极速编译。</p>\n<p>我们也做过一些对比测试数据，供大家参考：</p>\n<h4>多任务并行编译测试</h4>\n<table>\n<thead>\n<tr>\n<th>构建系统</th>\n<th>Termux (8core/-j12)</th>\n<th>构建系统</th>\n<th>MacOS (8core/-j12)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>xmake</td>\n<td>24.890s</td>\n<td>xmake</td>\n<td>12.264s</td>\n</tr>\n<tr>\n<td>ninja</td>\n<td>25.682s</td>\n<td>ninja</td>\n<td>11.327s</td>\n</tr>\n<tr>\n<td>cmake(gen+make)</td>\n<td>5.416s+28.473s</td>\n<td>cmake(gen+make)</td>\n<td>1.203s+14.030s</td>\n</tr>\n<tr>\n<td>cmake(gen+ninja)</td>\n<td>4.458s+24.842s</td>\n<td>cmake(gen+ninja)</td>\n<td>0.988s+11.644s</td>\n</tr>\n</tbody></table><h4>单任务编译测试</h4>\n<table>\n<thead>\n<tr>\n<th>构建系统</th>\n<th>Termux (-j1)</th>\n<th>构建系统</th>\n<th>MacOS (-j1)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>xmake</td>\n<td>1m57.707s</td>\n<td>xmake</td>\n<td>39.937s</td>\n</tr>\n<tr>\n<td>ninja</td>\n<td>1m52.845s</td>\n<td>ninja</td>\n<td>38.995s</td>\n</tr>\n<tr>\n<td>cmake(gen+make)</td>\n<td>5.416s+2m10.539s</td>\n<td>cmake(gen+make)</td>\n<td>1.203s+41.737s</td>\n</tr>\n<tr>\n<td>cmake(gen+ninja)</td>\n<td>4.458s+1m54.868s</td>\n<td>cmake(gen+ninja)</td>\n<td>0.988s+38.022s</td>\n</tr>\n</tbody></table><h3>傻瓜式多平台编译</h3>\n<p>XMake 的另外一个特点，就是高效简单的多平台编译，不管你是编译 windows/linux/macOS 下的程序，还是编译 iphoneos/android 又或者是交叉编译。</p>\n<p>编译的配置方式大同小异，不必让用户去这折腾研究各个平台下如何去编译。</p>\n<p><img alt=\"\" class=\"embedded_image\" loading=\"lazy\" referrerpolicy=\"no-referrer\" rel=\"noreferrer\" src=\"https://xmake.io/assets/img/index/xmake-basic-render.gif\"/></p>\n<h4>编译本机 Windows/Linux/MacOS  程序</h4>\n<p>当前本机程序编译，我们仅仅只需要执行：</p>\n<pre><code class=\"language-bash\">$ xmake\n</code></pre>\n<p>对比 CMake</p>\n<pre><code class=\"language-bash\">$ mkdir build\n$ cd build\n$ cmake --build ..\n</code></pre>\n<h4>编译 Android 程序</h4>\n<pre><code class=\"language-bash\">$ xmake f -p android --ndk=~/android-ndk-r21e\n$ xmake\n</code></pre>\n<p>对比 CMake</p>\n<pre><code class=\"language-bash\">$ mkdir build\n$ cd build\n$ cmake -DCMAKE_TOOLCHAIN_FILE=~/android-ndk-r21e/build/cmake/android.toolchain.cmake ..\n$ make\n</code></pre>\n<h4>编译 iOS 程序</h4>\n<pre><code class=\"language-bash\">$ xmake f -p iphoneos\n$ xmake\n</code></pre>\n<p>对比 CMake</p>\n<pre><code class=\"language-bash\">$ mkdir build\n$ cd build\n$ wget https://raw.githubusercontent.com/leetal/ios-cmake/master/ios.toolchain.cmake\n$ cmake -DCMAKE_TOOLCHAIN_FILE=`pwd`/ios.toolchain.cmake ..\n$ make\n</code></pre>\n<p>我没有找到很方便的方式去配置编译 ios 程序，仅仅只能从其他地方找到一个第三方的 ios 工具链去配置编译。</p>\n<h4>交叉编译</h4>\n<p>我们通常只需要设置交叉编译工具链根目录，XMake 会自动检测工具链结构，提取里面的编译器参与编译，不需要额外配置什么。</p>\n<pre><code class=\"language-bash\">$ xmake f -p cross --sdk=~/aarch64-linux-musl-cross\n$ xmake\n</code></pre>\n<p>对比 CMake</p>\n<p>我们需要先额外写一个 cross-toolchain.cmake 的交叉工具链配置文件。</p>\n<pre><code class=\"language-cmake\">set(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR aarch64)\n\nset(TOOL_CHAIN_DIR ~/aarch64-linux-musl)\nset(TOOL_CHAIN_INCLUDE ${TOOL_CHAIN_DIR}/aarch64-linux-musl/include)\nset(TOOL_CHAIN_LIB ${TOOL_CHAIN_DIR}/aarch64-linux-musl/lib)\n\nset(CMAKE_C_COMPILER \"aarch64-linux-gcc\")\nset(CMAKE_CXX_COMPILER \"aarch64-linux-g++\")\n\nset(CMAKE_FIND_ROOT_PATH ${TOOL_CHAIN_DIR}/aarch64-linux-musl)\n\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\n\ninclude_directories(${TOOL_CHAIN_DIR}/aarch64-linux-musl/include)\nset(CMAKE_INCLUDE_PATH ${TOOL_CHAIN_INCLUDE})\nset(CMAKE_LIBRARY_PATH ${TOOL_CHAIN_LIB})\n</code></pre>\n<pre><code class=\"language-bash\">$ mkdir build\n$ cd build\n$ cmake -DCMAKE_TOOLCHAIN_FILE=../cross-toolchain.cmake ..\n$ make\n</code></pre>\n<h3>结语</h3>\n<p>如果你是 C/C++ 开发的新手，可以通过 XMake 快速上手入门 C/C++ 编译构建。</p>\n<p>如果你想开发维护跨平台 C/C++ 项目，也可以考虑使用 XMake 来维护构建，提高开发效率，让你更加专注于项目本身，不再为折腾移植依赖库而烦恼。</p>\n<p>欢迎关注 XMake 项目：</p>\n<ul>\n<li><a href=\"https://github.com/xmake-io/xmake/\" rel=\"nofollow\">Github 项目地址</a></li>\n<li><a href=\"https://xmake.io/#/\" rel=\"nofollow\">项目主页</a></li>\n<li><a href=\"https://github.com/xmake-io/xmake-repo\" rel=\"nofollow\">XMake 包管理仓库</a></li>\n<li>\n社区<ul>\n<li><a href=\"https://t.me/tbooxorg\" rel=\"nofollow\">Telegram 群组</a></li>\n<li><a href=\"https://discord.gg/xmake\" rel=\"nofollow\">Discord 聊天室</a></li>\n<li>QQ 群：343118190, 662147501</li>\n<li>微信公众号：tboox-os</li>\n</ul>\n</li>\n<li>课程：<a href=\"https://xmake.io/#/zh-cn/about/course\" rel=\"nofollow\">Xmake 带你轻松构建 C/C++ 项目</a></li>\n<li>活动：<a href=\"https://tboox.org/cn/2021/04/29/xmake-summer-ospp/\" rel=\"nofollow\">开源之夏 &amp; Xmake</a></li>\n</ul>\n", "last_modified": 1620259117, "replies": 39, "id": 775065}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c51c/e410/13_large.png?m=1620107125", "name": "idev", "avatar_normal": "https://cdn.v2ex.com/navatar/c51c/e410/13_normal.png?m=1620107125", "title": "iDev", "url": "https://www.v2ex.com/go/idev", "topics": 3662, "footer": "可将讨论时涉及到的代码发布在 <a href=\"http://gist.github.com/\" target=\"_blank\">Gist</a> ，非常欢迎大家分享开发心得及讨论各种疑难问题。", "header": "iOS 及 OS X 开发技术讨论区，iOS 是 <a href=\"/go/iphone\">iPhone</a> 及 <a href=\"/go/ipad\">iPad</a> 上运行的操作系统。", "title_alternative": "iDev", "avatar_mini": "https://cdn.v2ex.com/navatar/c51c/e410/13_mini.png?m=1620107125", "stars": 1442, "aliases": [], "root": false, "id": 13, "parent_node_name": "dev"}, "member": {"username": "coldmn3", "website": null, "github": null, "psn": null, "avatar_normal": "https://cdn.v2ex.com/gravatar/e70eaffc27f91807f37bbdb03af1964b?s=24&d=retro", "bio": null, "url": "https://www.v2ex.com/u/coldmn3", "tagline": null, "twitter": null, "created": 1401075042, "avatar_large": "https://cdn.v2ex.com/gravatar/e70eaffc27f91807f37bbdb03af1964b?s=24&d=retro", "avatar_mini": "https://cdn.v2ex.com/gravatar/e70eaffc27f91807f37bbdb03af1964b?s=24&d=retro", "location": null, "btc": null, "id": 63609}, "last_reply_by": "crab", "last_touched": 1620317204, "title": "打款延迟，需要提供护照？", "url": "https://www.v2ex.com/t/775129", "created": 1620273071, "content": "http://ww1.sinaimg.cn/large/006zSPLrgy1gq8kd0awt6j310g17cn4w.jpg\r\n\r\n还要提供护照，是诈骗吗，不过确实是苹果邮箱发过来的", "content_rendered": "<img src=\"http://ww1.sinaimg.cn/large/006zSPLrgy1gq8kd0awt6j310g17cn4w.jpg\" class=\"embedded_image\" rel=\"noreferrer\" referrerpolicy=\"no-referrer\"> <br /><br />还要提供护照，是诈骗吗，不过确实是苹果邮箱发过来的", "last_modified": 1620273071, "replies": 39, "id": 775129}, {"node": {"avatar_large": "https://cdn.v2ex.com/navatar/c9e1/074f/104_large.png?m=1620107106", "name": "cloud", "avatar_normal": "https://cdn.v2ex.com/navatar/c9e1/074f/104_normal.png?m=1620107106", "title": "云计算", "url": "https://www.v2ex.com/go/cloud", "topics": 4421, "footer": "", "header": "关于云计算技术和平台的综合讨论区。", "title_alternative": "Cloud Computing", "avatar_mini": "https://cdn.v2ex.com/navatar/c9e1/074f/104_mini.png?m=1620107106", "stars": 2674, "aliases": [], "root": false, "id": 104, "parent_node_name": "webmaster"}, "member": {"username": "Grande", "website": "onekeyes.cn", "github": "onekeyes", "psn": "", "avatar_normal": "https://cdn.v2ex.com/avatar/cf19/b9fd/509722_mini.png?m=1615429038", "bio": "", "url": "https://www.v2ex.com/u/Grande", "tagline": "", "twitter": "", "created": 1601017082, "avatar_large": "https://cdn.v2ex.com/avatar/cf19/b9fd/509722_mini.png?m=1615429038", "avatar_mini": "https://cdn.v2ex.com/avatar/cf19/b9fd/509722_mini.png?m=1615429038", "location": "", "btc": "", "id": 509722}, "last_reply_by": "SenLief", "last_touched": 1620293098, "title": "阿里云， HK 节点轻量应用服务器这是上新了，不知线路如何？", "url": "https://www.v2ex.com/t/775103", "created": 1620269120, "content": "##  旧版 1c1g ssd 25g\r\n![]( https://cloud.onekeyes.cn/index.php/s/cp6JSCfCKx4Pbq6/preview)\r\n##  新版 2c1g essd 40g\r\n![]( https://cloud.onekeyes.cn/index.php/s/w7ecyF4GaKM6irz/preview)", "content_rendered": "<h2>旧版 1c1g ssd 25g</h2>\n<p><img alt=\"\" class=\"embedded_image\" loading=\"lazy\" referrerpolicy=\"no-referrer\" rel=\"noreferrer\" src=\"https://cloud.onekeyes.cn/index.php/s/cp6JSCfCKx4Pbq6/preview\"/></p>\n<h2>新版 2c1g essd 40g</h2>\n<p><img alt=\"\" class=\"embedded_image\" loading=\"lazy\" referrerpolicy=\"no-referrer\" rel=\"noreferrer\" src=\"https://cloud.onekeyes.cn/index.php/s/w7ecyF4GaKM6irz/preview\"/></p>\n", "last_modified": 1620276410, "replies": 33, "id": 775103}]